{"ast":null,"code":"import e, { useRef as o, useEffect as n, useState as i, useCallback as t } from \"react\";\nimport { UserAgent as a } from \"@apirtc/apirtc\";\nfunction s(i) {\n  const {\n      autoPlay: t = !0\n    } = i,\n    a = o(null);\n  return n(() => {\n    const e = a.current;\n    if (e && i.stream) return i.stream.attachToElement(e), () => {\n      e.src = \"\";\n    };\n  }, [i.stream]), e.createElement(\"video\", {\n    id: i.stream.getId(),\n    style: {\n      maxWidth: \"100%\"\n    },\n    ref: a,\n    autoPlay: t,\n    muted: i.muted\n  });\n}\nconst l = \"useCameraStream\";\nfunction r(e) {\n  let o = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  const [t, a] = i();\n  return n(() => {\n    if (e) {\n      e.getUserAgent().createStream(o).then(e => {\n        globalThis.apirtcReactLibLogLevel.isInfoEnabled && console.info(l + \"|createStream\", o, e), a(e);\n      }).catch(e => {\n        console.error(l + \"|createStream\", o, e), a(void 0);\n      });\n    } else a(void 0);\n  }, [e, JSON.stringify(o)]), n(() => () => {\n    t && (globalThis.apirtcReactLibLogLevel.isInfoEnabled && console.info(l + \"|release stream\", t), t.release());\n  }, [t]), {\n    stream: t\n  };\n}\nconst c = \"useConversation\";\nfunction b(e, o, a) {\n  let s = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : !1;\n  const [l, r] = i(),\n    [b, g] = i(!1),\n    [d, u] = i(!1),\n    L = t(() => (globalThis.apirtcReactLibLogLevel.isDebugEnabled && console.debug(c + \"|join\", l), new Promise((e, o) => {\n      l ? l.isJoined() ? o(c + \"|join|conversation already joined\") : (u(!0), l.join().then(() => {\n        g(!0), e();\n      }).catch(e => {\n        o(e);\n      }).finally(() => {\n        u(!1);\n      })) : o(c + \"|join|conversation not defined\");\n    })), [l]),\n    f = t(() => (globalThis.apirtcReactLibLogLevel.isDebugEnabled && console.debug(c + \"|leave\", l), new Promise((e, o) => {\n      l ? l.isJoined() ? l.leave().then(() => {\n        g(!1), e();\n      }).catch(e => {\n        o(e);\n      }) : o(c + \"|leave|conversation is not joined\") : o(c + \"|leave|conversation not defined\");\n    })), [l]);\n  return n(() => {\n    if (e && o) {\n      globalThis.apirtcReactLibLogLevel.isDebugEnabled && console.debug(c + \"|getOrCreateConversation\", o, a, s);\n      const n = e.getOrCreateConversation(o, a);\n      return r(n), () => {\n        globalThis.apirtcReactLibLogLevel.isDebugEnabled && console.debug(c + \"|useEffect cleanup\", o, a, s), n.isJoined() ? n.leave().then(() => {}).catch(e => {\n          globalThis.apirtcReactLibLogLevel.isWarnEnabled && console.warn(c + \"|useEffect conversation.leave()\", e);\n        }).finally(() => {\n          n.destroy(), r(void 0), g(!1);\n        }) : (n.destroy(), r(void 0));\n      };\n    }\n  }, [e, o, JSON.stringify(a)]), n(() => {\n    if (l && s) {\n      globalThis.apirtcReactLibLogLevel.isDebugEnabled && console.debug(c + \"|useEffect\", l, s);\n      const e = l,\n        o = s;\n      return o && (u(!0), e.join().then(() => {\n        globalThis.apirtcReactLibLogLevel.isInfoEnabled && console.info(c + \"|joined\", e), g(!0);\n      }).catch(e => {\n        globalThis.apirtcReactLibLogLevel.isWarnEnabled && console.warn(c + \"|useEffect conversation.join()\", e);\n      }).finally(() => {\n        u(!1);\n      })), () => {\n        globalThis.apirtcReactLibLogLevel.isDebugEnabled && console.debug(c + \"|useEffect cleanup\", e, o), e.isJoined() && e.leave().then(() => {\n          g(!1);\n        }).catch(e => {\n          globalThis.apirtcReactLibLogLevel.isWarnEnabled && console.warn(c + \"|useEffect conversation.leave()\", e);\n        });\n      };\n    }\n  }, [l, s]), {\n    conversation: l,\n    joining: d,\n    joined: b,\n    join: L,\n    leave: f\n  };\n}\nconst g = \"useConversationMessages\";\nfunction d(e) {\n  const [o] = i(new Array()),\n    [a, s] = i(new Array());\n  n(() => {\n    if (e) {\n      const n = n => {\n        globalThis.apirtcReactLibLogLevel.isInfoEnabled && console.info(g + \"|on:message:\", e.getName(), n), o.push(n), s(Array.from(o));\n      };\n      return e.on(\"message\", n), () => {\n        e.removeListener(\"message\", n), o.length = 0, s(new Array());\n      };\n    }\n  }, [e]);\n  return {\n    messages: a,\n    sendMessage: t((n, i) => new Promise((t, a) => {\n      null == e || e.sendMessage(n).then(a => {\n        globalThis.apirtcReactLibLogLevel.isInfoEnabled && console.info(g + \"|sentMessage\", e.getName(), a, n), o.push({\n          content: n,\n          sender: i,\n          time: new Date()\n        }), s(Array.from(o)), t();\n      }).catch(e => {\n        globalThis.apirtcReactLibLogLevel.isWarnEnabled && console.warn(g + \"|sendMessage error\", e), a(e);\n      });\n    }), [e])\n  };\n}\nconst u = \"useConversationModeration\";\nfunction L(e, o, t) {\n  const [a, s] = i(new Set());\n  return n(() => {\n    if (globalThis.apirtcReactLibLogLevel.isDebugEnabled && console.debug(u + \"|useEffect conversation\", e), e) {\n      const n = e => {\n          globalThis.apirtcReactLibLogLevel.isInfoEnabled && console.info(u + \"|on:contactJoinedWaitingRoom\", e), a.add(e), s(new Set(a));\n        },\n        i = e => {\n          globalThis.apirtcReactLibLogLevel.isInfoEnabled && console.info(u + \"|on:contactLeftWaitingRoom\", e), a.delete(e), s(new Set(a));\n        },\n        l = e => {\n          globalThis.apirtcReactLibLogLevel.isInfoEnabled && console.info(u + \"|on:participantEjected\", e), !0 === e.self ? (globalThis.apirtcReactLibLogLevel.isInfoEnabled && console.info(u + \"|Self participant was ejected\"), t && t()) : o && o(e.contact);\n        };\n      return e.on(\"contactJoinedWaitingRoom\", n).on(\"contactLeftWaitingRoom\", i).on(\"participantEjected\", l), () => {\n        globalThis.apirtcReactLibLogLevel.isDebugEnabled && console.debug(u + \"|conversation clear\", e), e.removeListener(\"contactJoinedWaitingRoom\", n).removeListener(\"contactLeftWaitingRoom\", i).removeListener(\"participantEjected\", l), s(new Set());\n      };\n    }\n  }, [e]), {\n    candidates: a\n  };\n}\nfunction f(e) {\n  return null != e;\n}\nconst p = \"useConversationStreams\";\nfunction h(e) {\n  let o = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n  let a = arguments.length > 2 ? arguments[2] : undefined;\n  globalThis.apirtcReactLibLogLevel.isDebugEnabled && console.debug(`${p}|hook`);\n  const [s, l] = i([]),\n    [r] = i(new Array()),\n    [c, b] = i(new Array()),\n    [g] = i(new Array()),\n    [d, u] = i(new Array()),\n    L = t((o, n) => new Promise((i, t) => {\n      e && (globalThis.apirtcReactLibLogLevel.isDebugEnabled && console.debug(`${p}|publish|${e.getName()}`, o, n), e.publish(o, n).then(o => {\n        globalThis.apirtcReactLibLogLevel.isInfoEnabled && console.info(`${p}|published|${e.getName()}`, o), r.push(o), b(Array.from(r)), i(o);\n      }).catch(e => {\n        t(e);\n      }));\n    }), [e]),\n    h = t((o, n, i) => new Promise((t, a) => {\n      if (e) {\n        globalThis.apirtcReactLibLogLevel.isDebugEnabled && console.debug(`${p}|replacePublishedStream|${e.getName()}|${o.getId()} -> ${n.getId()}(${JSON.stringify(i)})`);\n        const s = e.getConversationCall(o);\n        s && s.replacePublishedStream(n, void 0, i).then(n => {\n          globalThis.apirtcReactLibLogLevel.isInfoEnabled && console.info(`${p}|stream replaced|${e.getName()}`, o, n, i);\n          const a = r.indexOf(o);\n          a >= 0 && (r.splice(a, 1, n), b(Array.from(r))), t(n);\n        }).catch(e => {\n          a(e);\n        });\n      }\n    }), [e]),\n    v = t(o => {\n      if (e) {\n        globalThis.apirtcReactLibLogLevel.isDebugEnabled && console.debug(`${p}|unpublish|${e.getName()}`, o), e.unpublish(o);\n        const n = r.indexOf(o);\n        n >= 0 && (r.splice(n, 1), b(Array.from(r)));\n      }\n    }, [e]),\n    m = t(() => {\n      const n = Math.max(s.length, o.length);\n      globalThis.apirtcReactLibLogLevel.isDebugEnabled && console.debug(p + \"|doHandlePublication\", o, JSON.stringify(s.map(e => null == e ? void 0 : e.stream.getId())), n);\n      const i = [...o];\n      l(i);\n      const t = new Set(o.filter(f).map(e => e.stream));\n      for (let l = 0; l < n; l++) {\n        const n = s[l],\n          r = o[l];\n        if (n && r) {\n          const o = () => {\n            h(n.stream, r.stream, r.options).catch(e => {\n              i.splice(l, 1, null), a ? a(e) : globalThis.apirtcReactLibLogLevel.isWarnEnabled && console.warn(`${p}|replacePublishedStream|error`, e);\n            });\n          };\n          n.stream === r.stream ? JSON.stringify(n.options) !== JSON.stringify(r.options) && o() : t.has(n.stream) ? e && !e.isPublishedStream(r.stream) && L(r.stream, r.options).catch(e => {\n            i.splice(l, 1, null), a ? a(e) : globalThis.apirtcReactLibLogLevel.isWarnEnabled && console.warn(`${p}|publish|error`, e);\n          }) : e && !e.isPublishedStream(r.stream) ? o() : v(n.stream);\n        } else n && !r ? t.has(n.stream) || v(n.stream) : !n && r && e && !e.isPublishedStream(r.stream) && L(r.stream, r.options).catch(e => {\n          i.splice(l, 1, null), a ? a(e) : globalThis.apirtcReactLibLogLevel.isWarnEnabled && console.warn(`${p}|publish|error`, e);\n        });\n      }\n    }, [e, o, s, L, v, h]);\n  n(() => {\n    if (e) {\n      const o = e => {\n          globalThis.apirtcReactLibLogLevel.isInfoEnabled && console.info(p + \"|on_streamAdded\", e), g.push(e), u(Array.from(g));\n        },\n        n = e => {\n          globalThis.apirtcReactLibLogLevel.isInfoEnabled && console.info(p + \"|on_streamRemoved\", e);\n          const o = g.indexOf(e);\n          o >= 0 && (g.splice(o, 1), u(Array.from(g)));\n        },\n        i = o => {\n          const n = String(o.streamId);\n          !0 === o.isRemote && (\"added\" === o.listEventType ? e.subscribeToStream(n) : \"removed\" === o.listEventType && e.unsubscribeToStream(n));\n        };\n      return e.on(\"streamAdded\", o), e.on(\"streamRemoved\", n), e.on(\"streamListChanged\", i), () => {\n        e.removeListener(\"streamListChanged\", i), e.removeListener(\"streamRemoved\", n), e.removeListener(\"streamAdded\", o);\n      };\n    }\n  }, [e]);\n  const E = e => {\n    r.forEach(o => {\n      globalThis.apirtcReactLibLogLevel.isDebugEnabled && console.debug(p + \"|unpublish stream\", e, o), e.unpublish(o);\n    }), r.length = 0, l([]), g.forEach(o => {\n      globalThis.apirtcReactLibLogLevel.isDebugEnabled && console.debug(p + \"|unsubscribeToStream stream\", e, o), e.unsubscribeToStream(o.getId());\n    }), g.length = 0, b(new Array()), u(new Array());\n  };\n  return n(() => {\n    if (e) {\n      globalThis.apirtcReactLibLogLevel.isDebugEnabled && console.debug(p + \"|useEffect doHandlePublication\", e.getName());\n      const n = () => {\n          globalThis.apirtcReactLibLogLevel.isInfoEnabled && console.info(p + \"|on_joined\", e.getName(), o), m();\n        },\n        i = () => {\n          globalThis.apirtcReactLibLogLevel.isInfoEnabled && console.info(p + \"|on_left\", e.getName()), E(e);\n        };\n      return e.on(\"joined\", n), e.on(\"left\", i), () => {\n        e.removeListener(\"joined\", n), e.removeListener(\"left\", i);\n      };\n    }\n  }, [m]), n(() => {\n    if (e) return globalThis.apirtcReactLibLogLevel.isDebugEnabled && console.debug(`${p}|conversation|${e.getName()}`, e), e.getAvailableStreamList().forEach(o => {\n      const n = String(o.streamId);\n      !0 === o.isRemote && e.subscribeToStream(n);\n    }), () => {\n      E(e);\n    };\n  }, [e]), n(() => {\n    globalThis.apirtcReactLibLogLevel.isDebugEnabled && console.debug(`${p}|streamsToPublish`, JSON.stringify(o.map(e => (null == e ? void 0 : e.stream.getId()) + \"-\" + JSON.stringify(null == e ? void 0 : e.options)))), e && e.isJoined() && m();\n  }, [JSON.stringify(o.map(e => (null == e ? void 0 : e.stream.getId()) + \"-\" + JSON.stringify(null == e ? void 0 : e.options)))]), {\n    publishedStreams: c,\n    subscribedStreams: d,\n    publish: L,\n    unpublish: v,\n    replacePublishedStream: h\n  };\n}\nconst v = \"usePresence\";\nfunction m(e, o) {\n  const [t] = i(new Set()),\n    [a] = i(new Map()),\n    [s, l] = i(new Map());\n  n(() => {\n    if (e) return () => {\n      a.clear(), l(new Map(a)), t.clear();\n    };\n  }, [e]);\n  const r = e => {\n    var o;\n    const n = null !== (o = a.get(e)) && void 0 !== o ? o : new Set();\n    return a.has(e) || a.set(e, n), n;\n  };\n  return n(() => {\n    if (globalThis.apirtcReactLibLogLevel.isDebugEnabled && console.debug(v + \"|useEffect session, groups\", o), e) {\n      const n = e,\n        i = new Set(o);\n      i.forEach(e => {\n        t.has(e) || (globalThis.apirtcReactLibLogLevel.isInfoEnabled && console.info(v + \"|subscribeToGroup\", e), t.add(e), n.subscribeToGroup(e));\n      });\n      let s = !1;\n      if (t.forEach(e => {\n        i.has(e) || (globalThis.apirtcReactLibLogLevel.isInfoEnabled && console.info(v + \"|unsubscribeToGroup\", e), n.unsubscribeToGroup(e), t.delete(e), a.delete(e), s = !0);\n      }), s && l(new Map(a)), o.length > 0) {\n        const e = e => {\n          globalThis.apirtcReactLibLogLevel.isDebugEnabled && console.debug(v + \"|contactListUpdate\", e);\n          let o = !1;\n          for (const n of Object.keys(e.joinedGroup)) if (i.has(n)) {\n            const i = r(n);\n            for (const t of e.joinedGroup[n]) i.add(t), o = !0;\n          }\n          for (const n of Object.keys(e.leftGroup)) if (i.has(n)) {\n            const i = r(n);\n            for (const t of e.leftGroup[n]) i.delete(t), o = !0, 0 === i.size && a.delete(n);\n          }\n          for (const n of e.userDataChanged) for (const e of a.values()) if (e.has(n)) {\n            o = !0;\n            break;\n          }\n          o && l(new Map(a));\n        };\n        return n.on(\"contactListUpdate\", e), () => {\n          n.removeListener(\"contactListUpdate\", e);\n        };\n      }\n    }\n  }, [e, JSON.stringify(o)]), {\n    contactsByGroup: s\n  };\n}\nconst E = \"useSession\";\nfunction T(e, o) {\n  const [t, s] = i(),\n    [l, r] = i(!1),\n    [c, b] = i();\n  n(() => {\n    if (globalThis.apirtcReactLibLogLevel.isDebugEnabled && console.debug(E + \"|useEffect credentials, options\", e, o), e) {\n      let n = !0;\n      return g(e, o).catch(e => {\n        console.error(E + \"|connection failed\", e, n), s(void 0), n && b(e);\n      }), () => {\n        n = !1, s(void 0), r(!1), b(void 0);\n      };\n    }\n  }, [JSON.stringify(e), JSON.stringify(o)]), n(() => {\n    if (globalThis.apirtcReactLibLogLevel.isDebugEnabled && console.debug(E + \"|useEffect session\", t), t) {\n      const e = t;\n      return () => {\n        e.disconnect().then(() => {\n          globalThis.apirtcReactLibLogLevel.isInfoEnabled && console.info(E + \"|disconnected\", e);\n        }).catch(e => {\n          console.error(E + \"|disconnect\", e);\n        });\n      };\n    }\n  }, [t]);\n  const g = (e, o) => new Promise((n, i) => {\n    const t = o || {\n      cloudUrl: \"https://cloud.apirtc.com\"\n    };\n    let l;\n    if (\"object\" == typeof (c = e) && \"username\" in c) t.password = e.password, l = new a({\n      uri: \"apirtc:\" + e.username\n    });else if (function (e) {\n      return \"object\" == typeof e && \"apiKey\" in e;\n    }(e)) l = new a({\n      uri: `apiKey:${e.apiKey}`\n    });else {\n      if (!function (e) {\n        return \"object\" == typeof e && \"token\" in e;\n      }(e)) return void i(\"credentials not recognized\");\n      l = new a({\n        uri: `token:${e.token}`\n      });\n    }\n    var c;\n    r(!0), l.register(t).then(e => {\n      globalThis.apirtcReactLibLogLevel.isInfoEnabled && console.info(E + \"|connected\", e), s(e), n();\n    }).catch(e => {\n      i(e);\n    }).finally(() => {\n      r(!1);\n    });\n  });\n  return {\n    session: t,\n    connecting: l,\n    connect: g,\n    disconnect: () => {\n      s(void 0);\n    },\n    error: c\n  };\n}\nconst R = \"useStreamApplyVideoProcessor\";\nfunction y(e, o, a, s) {\n  const [l, r] = i(e),\n    [c, b] = i(\"none\");\n  n(() => {\n    globalThis.apirtcReactLibLogLevel.isDebugEnabled && console.debug(R + \"|useEffect\", e, o, a), e && \"none\" !== o ? e.applyVideoProcessor(o, a).then(e => {\n      r(e), b(o);\n    }).catch(n => {\n      r(e), s ? s(n) : globalThis.apirtcReactLibLogLevel.isWarnEnabled && console.warn(R + \"|useEffect\", e, o, a, n), b(e => e);\n    }) : (r(e), b(\"none\"));\n  }, [e, o, a]);\n  const g = t(() => {\n    l && l !== e && (globalThis.apirtcReactLibLogLevel.isDebugEnabled && console.debug(R + \"|releasing outStream\", l), l.release());\n  }, [e, l]);\n  return n(() => () => {\n    g();\n  }, [l]), {\n    stream: l,\n    applied: c\n  };\n}\nconst S = {\n  audioinput: {},\n  audiooutput: {},\n  videoinput: {}\n};\nfunction w(e) {\n  const [o, t] = i(S);\n  return n(() => {\n    if (e) {\n      const o = e.getUserAgent(),\n        n = () => {\n          const e = o.getUserMediaDevices();\n          globalThis.apirtcReactLibLogLevel.isInfoEnabled && console.info(\"useUserMediaDevices|mediaDeviceChanged\", e), t(e);\n        };\n      return o.on(\"mediaDeviceChanged\", n), () => {\n        o.removeListener(\"mediaDeviceChanged\", n), t(S);\n      };\n    }\n  }, [e]), {\n    userMediaDevices: o\n  };\n}\nconst D = {\n  level: \"info\",\n  isDebugEnabled: !1,\n  isInfoEnabled: !0,\n  isWarnEnabled: !0\n};\nfunction I(e) {\n  switch (e) {\n    case \"debug\":\n      globalThis.apirtcReactLibLogLevel = {\n        level: \"debug\",\n        isDebugEnabled: !0,\n        isInfoEnabled: !0,\n        isWarnEnabled: !0\n      };\n      break;\n    case \"info\":\n    default:\n      globalThis.apirtcReactLibLogLevel = D;\n      break;\n    case \"warn\":\n      globalThis.apirtcReactLibLogLevel = {\n        level: \"warn\",\n        isDebugEnabled: !1,\n        isInfoEnabled: !1,\n        isWarnEnabled: !0\n      };\n      break;\n    case \"error\":\n      globalThis.apirtcReactLibLogLevel = {\n        level: \"error\",\n        isDebugEnabled: !1,\n        isInfoEnabled: !1,\n        isWarnEnabled: !1\n      };\n  }\n  return globalThis.apirtcReactLibLogLevel;\n}\nglobalThis.apirtcReactLibLogLevel = D, globalThis.setApirtcReactLibLogLevel = I;\nexport { s as VideoStream, I as setLogLevel, r as useCameraStream, b as useConversation, d as useConversationMessages, L as useConversationModeration, h as useConversationStreams, m as usePresence, T as useSession, y as useStreamApplyVideoProcessor, w as useUserMediaDevices };","map":{"version":3,"mappings":"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","names":["props","autoPlay","videoRef","useRef","useEffect","ref","current","stream","attachToElement","src","React","createElement","id","getId","style","maxWidth","muted","HOOK_NAME","session","options","setStream","useState","getUserAgent","createStream","then","localStream","globalThis","apirtcReactLibLogLevel","isInfoEnabled","console","info","catch","error","undefined","JSON","stringify","release","name","join","conversation","setConversation","joined","setJoined","joining","setJoining","o_join","useCallback","isDebugEnabled","debug","Promise","resolve","reject","isJoined","finally","o_leave","leave","l_conversation","getOrCreateConversation","isWarnEnabled","warn","destroy","l_join","messages","Array","o_messages","setO_Messages","onMessage","message","getName","push","from","on","removeListener","length","sendMessage","msgContent","sender","uuid","content","time","Date","onEjected","onEjectedSelf","candidates","setCandidates","Set","on_contactJoinedWaitingRoom","contact","add","on_contactLeftWaitingRoom","delete","on_participantEjected","data","self","notEmpty","value","errorCallback","streamsToPublish","publishedStreamsCache","setPublishedStreamsCache","publishedStreams","o_publishedStreams","setO_PublishedStreams","subscribedStreams","o_subscribedStreams","setO_SubscribedStreams","publish","replacePublishedStream","oldStream","newStream","conversationCall","getConversationCall","index","indexOf","splice","unpublish","doHandlePublication","maxLength","Math","max","map","l_s","newPublishedStreamsCache","streamsToPublishSet","filter","item","i","previous","next","doReplacePublishedStream","has","isPublishedStream","on_streamAdded","remoteStream","on_streamRemoved","on_streamListChanged","streamInfo","streamId","String","isRemote","listEventType","subscribeToStream","unsubscribeToStream","unpublishAndUnsubscribeAll","i_conversation","forEach","on_joined","on_left","getAvailableStreamList","usePresence","groups","groupsCache","m_contactsByGroup","Map","contactsByGroup","setContactsByGroup","clear","getOrCreateGroupSet","group","o_set","_a","get","set","l_session","l_groupsSet","subscribeToGroup","needsRefresh","unsubscribeToGroup","onContactListUpdate","updatedContacts","Object","keys","joinedGroup","l_set","leftGroup","size","userDataChanged","l_contacts","values","useSession","credentials","setSession","connecting","setConnecting","setError","isMounted","connect","disconnect","registerInformation","cloudUrl","l_userAgent","object","password","UserAgent","uri","username","isInstanceOfApiKey","apiKey","isInstanceOfToken","token","register","useStreamApplyVideoProcessor","videoProcessorType","outStream","setOutStream","applied","setApplied","applyVideoProcessor","l_stream","previousValue","doCheckAndReleaseOutStream","EMPTY_LIST","audioinput","audiooutput","videoinput","userMediaDevices","setUserMediaDevices","userAgent","on_mediaDeviceChanged","mediaDevices","getUserMediaDevices","INFO","level","setLogLevel","logLevelText","setApirtcReactLibLogLevel"],"sources":["/home/romain/code/react-lib-test/react-hook-basic/node_modules/@apirtc/react-lib/src/components/VideoStream/VideoStream.tsx","/home/romain/code/react-lib-test/react-hook-basic/node_modules/@apirtc/react-lib/src/hooks/useCameraStream.ts","/home/romain/code/react-lib-test/react-hook-basic/node_modules/@apirtc/react-lib/src/hooks/useConversation.ts","/home/romain/code/react-lib-test/react-hook-basic/node_modules/@apirtc/react-lib/src/hooks/useConversationMessages.ts","/home/romain/code/react-lib-test/react-hook-basic/node_modules/@apirtc/react-lib/src/hooks/useConversationModeration.ts","/home/romain/code/react-lib-test/react-hook-basic/node_modules/@apirtc/react-lib/src/hooks/useConversationStreams.ts","/home/romain/code/react-lib-test/react-hook-basic/node_modules/@apirtc/react-lib/src/hooks/usePresence.ts","/home/romain/code/react-lib-test/react-hook-basic/node_modules/@apirtc/react-lib/src/hooks/useSession.ts","/home/romain/code/react-lib-test/react-hook-basic/node_modules/@apirtc/react-lib/src/hooks/useStreamApplyVideoProcessor.ts","/home/romain/code/react-lib-test/react-hook-basic/node_modules/@apirtc/react-lib/src/hooks/useUserMediaDevices.ts","/home/romain/code/react-lib-test/react-hook-basic/node_modules/@apirtc/react-lib/src/index.ts"],"sourcesContent":["import React, { useEffect, useRef } from 'react'\nimport { Stream } from '@apirtc/apirtc'\n\n// tried const Video = styled.video`\n//     max-width: 100%;\n// `\n// or\n// /* override other styles to make responsive */\n// width: 100%    !important;\n// height: auto   !important;\n// or\n// return <video width=\"100%\" ...\n//\n// but for all there is a problem then in react display...\n\nexport interface VideoStreamProps {\n    stream: Stream,\n    autoPlay?: boolean,\n    muted?: boolean\n}\nexport default function VideoStream(props: VideoStreamProps) {\n\n    // default autoPlay\n    const { autoPlay = true } = props;\n\n    const videoRef = useRef<HTMLVideoElement>(null)\n\n    useEffect(() => {\n        const ref = videoRef.current;\n        if (ref && props.stream) {\n            props.stream.attachToElement(ref)\n            return () => {\n                ref.src = \"\";\n            }\n        }\n    }, [props.stream])\n    // No need to put videoRef.current because useRef does not trigger rerender anyways\n\n    return <video id={props.stream.getId()} style={{ maxWidth: '100%' }}\n        ref={videoRef}\n        autoPlay={autoPlay}\n        muted={props.muted}></video>\n}","import { useState, useEffect } from 'react'\nimport { CreateStreamOptions, Session, Stream, UserAgent } from '@apirtc/apirtc'\n\nconst HOOK_NAME = \"useCameraStream\";\nexport default function useCameraStream(\n    session: Session | undefined,\n    options: CreateStreamOptions = {}\n) {\n    const [stream, setStream] = useState<Stream>();\n\n    useEffect(() => {\n        if (session) {\n            const userAgent: UserAgent = session.getUserAgent();\n            userAgent.createStream(options).then((localStream: Stream) => {\n                if (globalThis.apirtcReactLibLogLevel.isInfoEnabled) {\n                    console.info(HOOK_NAME + \"|createStream\", options, localStream)\n                }\n                setStream(localStream)\n            }).catch((error: any) => {\n                console.error(HOOK_NAME + \"|createStream\", options, error)\n                setStream(undefined)\n            })\n\n            // DO NOT set out stream to undefined in the return, to prevent unnecessary refreshes\n            // of other components with undefined stream, whereas we are expecting to change it\n            // to another instance..\n            // return () => { setStream(undefined) } // DON'T\n        } else {\n            setStream(undefined)\n        }\n\n    }, [session, JSON.stringify(options)])\n\n    useEffect(() => {\n        return () => {\n            if (stream) {\n                if (globalThis.apirtcReactLibLogLevel.isInfoEnabled) {\n                    console.info(HOOK_NAME + \"|release stream\", stream)\n                }\n                stream.release()\n            }\n        }\n    }, [stream])\n\n    return {\n        stream\n    }\n}","import { useState, useEffect, useCallback } from 'react'\nimport { Conversation, GetOrCreateConversationOptions, Session } from '@apirtc/apirtc'\n\nconst HOOK_NAME = \"useConversation\";\n/**\n * Please note that the hook won't react on autoJoin change\n */\nexport default function useConversation(\n    session: Session | undefined,\n    name: string | undefined,\n    options?: GetOrCreateConversationOptions,\n    join: boolean = false\n) {\n    const [conversation, setConversation] = useState<Conversation>();\n    const [joined, setJoined] = useState<boolean>(false);\n    const [joining, setJoining] = useState<boolean>(false);\n\n    // Callbacks\n    //\n    // Offering Promised join/leave methods allows developer to act on then/catch\n    //\n    const o_join = useCallback(() => {\n        if (globalThis.apirtcReactLibLogLevel.isDebugEnabled) {\n            console.debug(HOOK_NAME + \"|join\", conversation)\n            //JSON.stringify((apiRTC as any).session.apiCCWebRTCClient.webRTCClient.MCUClient.sessionMCUs))\n        }\n        return new Promise<void>((resolve, reject) => {\n            if (!conversation) {\n                reject(HOOK_NAME + \"|join|conversation not defined\")\n                return\n            }\n            if (!conversation.isJoined()) {\n                setJoining(true)\n                conversation.join().then(() => {\n                    // successfully joined the conversation.\n                    setJoined(true)\n                    resolve()\n                }).catch((error: any) => {\n                    // could not join the conversation.\n                    reject(error)\n                }).finally(() => {\n                    setJoining(false)\n                })\n            } else {\n                reject(HOOK_NAME + \"|join|conversation already joined\")\n            }\n        })\n    }, [conversation]);\n\n    const o_leave = useCallback(() => {\n        if (globalThis.apirtcReactLibLogLevel.isDebugEnabled) {\n            console.debug(HOOK_NAME + \"|leave\", conversation)\n        }\n        return new Promise<void>((resolve, reject) => {\n            if (!conversation) {\n                reject(HOOK_NAME + \"|leave|conversation not defined\")\n                return\n            }\n            if (conversation.isJoined()) {\n                conversation.leave().then(() => {\n                    // local user successfully left the conversation.\n                    setJoined(false)\n                    resolve()\n                }).catch((error: any) => {\n                    reject(error)\n                })\n            } else {\n                reject(HOOK_NAME + \"|leave|conversation is not joined\")\n            }\n        })\n    }, [conversation]);\n\n    // Effects\n    //\n    useEffect(() => {\n        if (session && name) {\n            if (globalThis.apirtcReactLibLogLevel.isDebugEnabled) {\n                console.debug(HOOK_NAME + \"|getOrCreateConversation\", name, options, join)\n            }\n            const l_conversation = session.getOrCreateConversation(name, options);\n            setConversation(l_conversation)\n            return () => {\n                if (globalThis.apirtcReactLibLogLevel.isDebugEnabled) {\n                    console.debug(HOOK_NAME + \"|useEffect cleanup\", name, options, join)\n                }\n                if (l_conversation.isJoined()) {\n                    l_conversation.leave()\n                        .then(() => { })\n                        .catch((error: any) => {\n                            if (globalThis.apirtcReactLibLogLevel.isWarnEnabled) {\n                                console.warn(HOOK_NAME + \"|useEffect conversation.leave()\", error)\n                            }\n                        })\n                        .finally(() => {\n                            l_conversation.destroy()\n                            setConversation(undefined)\n                            setJoined(false)\n                        })\n                } else {\n                    // It is important to destroy the conversation.\n                    // Otherwise subsequent getOrCreateConversation with same name would get\n                    // previous handle, regardless of the potentially new options.\n                    // This also allows to cleanup memory\n                    l_conversation.destroy()\n                    setConversation(undefined)\n                }\n            }\n        }\n    }, [session, name, JSON.stringify(options)])\n\n    useEffect(() => {\n        if (conversation && join) {\n            if (globalThis.apirtcReactLibLogLevel.isDebugEnabled) {\n                console.debug(HOOK_NAME + \"|useEffect\", conversation, join)\n            }\n            const l_conversation = conversation;\n            const l_join = join;\n            if (l_join) {\n                setJoining(true)\n                l_conversation.join().then(() => {\n                    if (globalThis.apirtcReactLibLogLevel.isInfoEnabled) {\n                        console.info(HOOK_NAME + \"|joined\", l_conversation)\n                    }\n                    setJoined(true)\n                }).catch((error: any) => {\n                    if (globalThis.apirtcReactLibLogLevel.isWarnEnabled) {\n                        console.warn(HOOK_NAME + \"|useEffect conversation.join()\", error)\n                    }\n                }).finally(() => {\n                    setJoining(false)\n                })\n            }\n            return () => {\n                if (globalThis.apirtcReactLibLogLevel.isDebugEnabled) {\n                    console.debug(HOOK_NAME + \"|useEffect cleanup\", l_conversation, l_join)\n                }\n                if (l_conversation.isJoined()) {\n                    l_conversation.leave().then(() => {\n                        setJoined(false)\n                    }).catch((error: any) => {\n                        if (globalThis.apirtcReactLibLogLevel.isWarnEnabled) {\n                            console.warn(HOOK_NAME + \"|useEffect conversation.leave()\", error)\n                        }\n                    })\n                }\n            }\n        }\n    }, [conversation, join])\n\n    return {\n        conversation,\n        joining,\n        joined,\n        join: o_join,\n        leave: o_leave\n    }\n}","import { useState, useEffect, useCallback } from 'react'\nimport { Contact, Conversation, ConversationMessage } from '@apirtc/apirtc'\n\n// TODO : get and handle with pagination messages history\n// TODO : ask apirtc to include the uuid in ConversationMessage so that we can store it\n// into ConversationMessage when creating the local one, and we get it from conversation on:message\n// the uuid shall be the value used as a react child key when displaying list of messages\n\nconst HOOK_NAME = \"useConversationMessages\";\nexport default function useConversationMessages(\n    conversation: Conversation | undefined,\n) {\n    // Use an internal array which will always be the same object as far as React knows\n    // This will avoid the need for adding it as a dependency for each callback\n    const [messages] = useState<Array<ConversationMessage>>(new Array<ConversationMessage>());\n    // And use a copy as output array so that client code will react upon change\n    // (only a new instance of array is detected by React)\n    const [o_messages, setO_Messages] = useState<Array<ConversationMessage>>(new Array<ConversationMessage>());\n\n    useEffect(() => {\n        if (conversation) {\n            const onMessage = (message: ConversationMessage) => {\n                if (globalThis.apirtcReactLibLogLevel.isInfoEnabled) {\n                    console.info(HOOK_NAME + \"|on:message:\", conversation.getName(), message)\n                }\n                messages.push(message)\n                setO_Messages(Array.from(messages))\n            };\n            conversation.on('message', onMessage)\n\n            return () => {\n                conversation.removeListener('message', onMessage)\n                messages.length = 0;\n                setO_Messages(new Array<any>())\n            }\n        }\n    }, [conversation])\n\n    const sendMessage = useCallback((msgContent: string, sender: Contact) => {\n        return new Promise<void>((resolve, reject) => {\n            conversation?.sendMessage(msgContent)\n                .then((uuid: number) => {\n                    if (globalThis.apirtcReactLibLogLevel.isInfoEnabled) {\n                        console.info(HOOK_NAME + \"|sentMessage\", conversation.getName(), uuid, msgContent)\n                    }\n                    messages.push({ content: msgContent, sender: sender, time: new Date() })\n                    setO_Messages(Array.from(messages))\n                    resolve()\n                })\n                .catch((error: any) => {\n                    if (globalThis.apirtcReactLibLogLevel.isWarnEnabled) {\n                        console.warn(HOOK_NAME + \"|sendMessage error\", error)\n                    }\n                    reject(error)\n                })\n        })\n    }, [conversation]);\n\n    return {\n        messages: o_messages,\n        sendMessage\n    }\n}","import { useState, useEffect } from 'react'\nimport { Contact, Conversation } from '@apirtc/apirtc'\n\nconst HOOK_NAME = \"useConversationModeration\";\nexport default function useConversationModeration(\n    conversation: Conversation | undefined,\n    onEjected?: (contact: Contact) => void,\n    onEjectedSelf?: () => void) {\n\n    const [candidates, setCandidates] = useState<Set<Contact>>(new Set<Contact>());\n\n    useEffect(() => {\n        if (globalThis.apirtcReactLibLogLevel.isDebugEnabled) {\n            console.debug(HOOK_NAME + \"|useEffect conversation\", conversation)\n        }\n\n        if (conversation) {\n            const on_contactJoinedWaitingRoom = (contact: Contact) => {\n                if (globalThis.apirtcReactLibLogLevel.isInfoEnabled) {\n                    console.info(HOOK_NAME + \"|on:contactJoinedWaitingRoom\", contact)\n                }\n                // A candidate joined the waiting room.\n                candidates.add(contact)\n                setCandidates(new Set(candidates))\n            };\n            const on_contactLeftWaitingRoom = (contact: Contact) => {\n                if (globalThis.apirtcReactLibLogLevel.isInfoEnabled) {\n                    console.info(HOOK_NAME + \"|on:contactLeftWaitingRoom\", contact)\n                }\n                // A candidate left the waiting room.\n                candidates.delete(contact)\n                setCandidates(new Set(candidates))\n            };\n            // TODO make apirtc.d.ts update to replace 'any'\n            const on_participantEjected = (data: any) => {\n                if (globalThis.apirtcReactLibLogLevel.isInfoEnabled) {\n                    console.info(HOOK_NAME + \"|on:participantEjected\", data)\n                }\n                if (data.self === true) {\n                    if (globalThis.apirtcReactLibLogLevel.isInfoEnabled) {\n                        console.info(HOOK_NAME + \"|Self participant was ejected\")\n                    }\n                    if (onEjectedSelf) {\n                        onEjectedSelf()\n                    }\n                } else {\n                    if (onEjected) {\n                        onEjected(data.contact)\n                    }\n                }\n            };\n\n            conversation\n                .on('contactJoinedWaitingRoom', on_contactJoinedWaitingRoom)\n                .on('contactLeftWaitingRoom', on_contactLeftWaitingRoom)\n                .on('participantEjected', on_participantEjected)\n\n            return () => {\n                if (globalThis.apirtcReactLibLogLevel.isDebugEnabled) {\n                    console.debug(HOOK_NAME + \"|conversation clear\", conversation)\n                }\n                // remove listeners\n                conversation\n                    .removeListener('contactJoinedWaitingRoom', on_contactJoinedWaitingRoom)\n                    .removeListener('contactLeftWaitingRoom', on_contactLeftWaitingRoom)\n                    .removeListener('participantEjected', on_participantEjected)\n                setCandidates(new Set())\n            }\n        }\n    }, [conversation])\n\n    return {\n        candidates\n    }\n}","import { useState, useEffect, useCallback } from 'react'\nimport { Conversation, PublishOptions, Stream, StreamInfo } from '@apirtc/apirtc'\n\n// TODO?: add pagination ?\n// interface Options {\n//   streamsSubscribePageSize: number\n// }\n\nfunction notEmpty<T>(value: T | null | undefined): value is T {\n  return value !== null && value !== undefined;\n}\n\nconst HOOK_NAME = \"useConversationStreams\";\nexport default function useConversationStreams(\n  conversation: Conversation | undefined,\n  /** fully managed list of Stream(s) to publish, with associated publish options */\n  streamsToPublish: Array<{ stream: Stream, options?: PublishOptions } | undefined | null> = [],\n  errorCallback?: (error: any) => void\n) {\n\n  if (globalThis.apirtcReactLibLogLevel.isDebugEnabled) {\n    console.debug(`${HOOK_NAME}|hook`)\n  }\n\n  // A cache to handle publication differences\n  const [publishedStreamsCache, setPublishedStreamsCache] =\n    useState<Array<{ stream: Stream, options?: PublishOptions } | undefined | null>>([]);\n\n  // Use an internal array which will always be the same object as far as React knows\n  // This will avoid the need for adding it as a dependency for each callback\n  const [publishedStreams] = useState<Array<Stream>>(new Array<Stream>());\n  // And use a copy as output array so that client code will react upon change\n  // (only a new instance of array is detected by React)\n  const [o_publishedStreams, setO_PublishedStreams] = useState<Array<Stream>>(new Array<Stream>());\n\n  const [subscribedStreams] = useState<Array<Stream>>(new Array<Stream>());\n  const [o_subscribedStreams, setO_SubscribedStreams] = useState<Array<Stream>>(new Array<Stream>());\n\n  const publish: (localStream: Stream, options?: PublishOptions) => Promise<Stream> =\n    useCallback((localStream: Stream, options?: PublishOptions) => {\n      return new Promise<Stream>((resolve, reject) => {\n        if (conversation) {\n          if (globalThis.apirtcReactLibLogLevel.isDebugEnabled) {\n            console.debug(`${HOOK_NAME}|publish|${conversation.getName()}`, localStream, options)\n          }\n          conversation.publish(localStream, options).then((stream: Stream) => {\n            if (globalThis.apirtcReactLibLogLevel.isInfoEnabled) {\n              console.info(`${HOOK_NAME}|published|${conversation.getName()}`, stream)\n            }\n            //console.log(`PUSHING ${stream.getId()} to publishedStreams`, JSON.stringify(publishedStreams.map(s => s.getId())))\n            publishedStreams.push(stream)\n            // Returning a new array makes lets React detect changes\n            setO_PublishedStreams(Array.from(publishedStreams))\n            resolve(stream)\n          }).catch((error: any) => {\n            reject(error)\n          })\n        }\n      })\n    }, [conversation]);\n\n  const replacePublishedStream = useCallback((oldStream: Stream, newStream: Stream, options?: PublishOptions) => {\n    return new Promise<Stream>((resolve, reject) => {\n      if (conversation) {\n        if (globalThis.apirtcReactLibLogLevel.isDebugEnabled) {\n          console.debug(`${HOOK_NAME}|replacePublishedStream|${conversation.getName()}|${oldStream.getId()} -> ${newStream.getId()}(${JSON.stringify(options)})`)\n        }\n        const conversationCall = conversation.getConversationCall(oldStream);\n        if (conversationCall) {\n          conversationCall.replacePublishedStream(newStream, undefined, options)\n            .then((stream: Stream) => {\n              if (globalThis.apirtcReactLibLogLevel.isInfoEnabled) {\n                console.info(`${HOOK_NAME}|stream replaced|${conversation.getName()}`, oldStream, stream, options)\n              }\n              const index = publishedStreams.indexOf(oldStream);\n              if (index >= 0) {\n                publishedStreams.splice(index, 1, stream)\n                setO_PublishedStreams(Array.from(publishedStreams))\n              }\n              resolve(stream)\n            }).catch((error: any) => {\n              reject(error)\n            })\n        }\n      }\n    })\n  }, [conversation]);\n\n  const unpublish: (localStream: Stream) => void = useCallback((localStream: Stream) => {\n    if (conversation) {\n      if (globalThis.apirtcReactLibLogLevel.isDebugEnabled) {\n        console.debug(`${HOOK_NAME}|unpublish|${conversation.getName()}`, localStream)\n      }\n      conversation.unpublish(localStream)\n      const index = publishedStreams.indexOf(localStream);\n      if (index >= 0) {\n        publishedStreams.splice(index, 1)\n        setO_PublishedStreams(Array.from(publishedStreams))\n      }\n    }\n  }, [conversation]);\n\n  const doHandlePublication = useCallback(() => {\n    const maxLength = Math.max(publishedStreamsCache.length, streamsToPublish.length);\n    if (globalThis.apirtcReactLibLogLevel.isDebugEnabled) {\n      console.debug(HOOK_NAME + \"|doHandlePublication\", streamsToPublish,\n        JSON.stringify(publishedStreamsCache.map(l_s => l_s?.stream.getId())), maxLength)\n    }\n\n    // Strategy for published streams cache is to initialize it as it should be\n    // and remove items if publication fails.\n    const newPublishedStreamsCache = [...streamsToPublish];\n    setPublishedStreamsCache(newPublishedStreamsCache)\n\n    // Prepare a set for Streams to publish, for further optimized check\n    const streamsToPublishSet = new Set(streamsToPublish.filter(notEmpty).map((item) => item.stream));\n\n    // Loop on arrays index to publish new streams, or replace if necessary\n    for (let i = 0; i < maxLength; i++) {\n      const previous = publishedStreamsCache[i];\n      const next = streamsToPublish[i];\n\n      if (previous && next) {\n        const doReplacePublishedStream = () => {\n          replacePublishedStream(previous.stream, next.stream, next.options)\n            .catch((error: Error) => {\n              newPublishedStreamsCache.splice(i, 1, null)\n              if (errorCallback) {\n                errorCallback(error)\n              } else if (globalThis.apirtcReactLibLogLevel.isWarnEnabled) {\n                console.warn(`${HOOK_NAME}|replacePublishedStream|error`, error)\n              }\n            })\n        }\n        if (previous.stream === next.stream) {\n          // Streams are the same, only replace if options are different\n          if (JSON.stringify(previous.options) !== JSON.stringify(next.options)) {\n            doReplacePublishedStream()\n          }\n        } else {\n          // If position in both new and cached list are defined but are different:\n          // replace if and only if stream to unpublish shall not be published (at other position)\n          if (streamsToPublishSet.has(previous.stream)) { // previous shall be published\n            // Previous shall actually be published (at another position), so don't do anything about it\n            // But then we still have to publish new stream (if not already published)\n            if (conversation && !conversation.isPublishedStream(next.stream)) {\n              publish(next.stream, next.options).catch((error: Error) => {\n                newPublishedStreamsCache.splice(i, 1, null)\n                if (errorCallback) {\n                  errorCallback(error)\n                } else if (globalThis.apirtcReactLibLogLevel.isWarnEnabled) {\n                  console.warn(`${HOOK_NAME}|publish|error`, error)\n                }\n              })\n            }\n          } else {\n            if (conversation && !conversation.isPublishedStream(next.stream)) {\n              doReplacePublishedStream()\n            } else { // new stream is already published\n              // So we shall not replace another stream by it, but we need to unpublish the previous\n              unpublish(previous.stream)\n            }\n          }\n        }\n      } else if (previous && !next) {\n        // If position in new list is now undefined(or null) while it was in cache:\n        // unpublish if and only if stream to unpublish shall not be published (at other position)\n        if (!streamsToPublishSet.has(previous.stream)) {\n          unpublish(previous.stream)\n        }\n      } else if (!previous && next) {\n        // If position in new list is valid : publish it whatever the position in cache.\n        // Depending on the case the stream might be already published, or it might be not\n        // (can happen if the cache was set while Conversation was not joined yet).\n        // Note that we could try to publish without checking isPublishedStream, the call would\n        // reject with a console error but this would not affect the behavior.\n        if (conversation && !conversation.isPublishedStream(next.stream)) {\n          publish(next.stream, next.options).catch((error: Error) => {\n            newPublishedStreamsCache.splice(i, 1, null)\n            if (errorCallback) {\n              errorCallback(error)\n            } else if (globalThis.apirtcReactLibLogLevel.isWarnEnabled) {\n              console.warn(`${HOOK_NAME}|publish|error`, error)\n            }\n          })\n        }\n      }\n    }\n  }, [conversation,\n    streamsToPublish,\n    publishedStreamsCache,\n    publish, unpublish, replacePublishedStream]);\n\n  // --------------------------------------------------------------------------\n  // useEffect(s) - Order is important\n  //\n  useEffect(() => {\n    if (conversation) {\n      const on_streamAdded = (remoteStream: Stream) => {\n        if (globalThis.apirtcReactLibLogLevel.isInfoEnabled) {\n          console.info(HOOK_NAME + \"|on_streamAdded\", remoteStream)\n        }\n        subscribedStreams.push(remoteStream)\n        setO_SubscribedStreams(Array.from(subscribedStreams))\n      };\n      const on_streamRemoved = (remoteStream: Stream) => {\n        if (globalThis.apirtcReactLibLogLevel.isInfoEnabled) {\n          console.info(HOOK_NAME + \"|on_streamRemoved\", remoteStream)\n        }\n        const index = subscribedStreams.indexOf(remoteStream);\n        if (index >= 0) {\n          subscribedStreams.splice(index, 1)\n          setO_SubscribedStreams(Array.from(subscribedStreams))\n        }\n      };\n      const on_streamListChanged = (streamInfo: StreamInfo) => {\n        const streamId = String(streamInfo.streamId);\n        if (streamInfo.isRemote === true) {\n          if (streamInfo.listEventType === 'added') {\n            // a remote stream was published\n            conversation.subscribeToStream(streamId)\n          } else if (streamInfo.listEventType === 'removed') {\n            // a remote stream is not published anymore\n            conversation.unsubscribeToStream(streamId)\n          }\n        }\n      };\n      // Subscribe to incoming streams\n      conversation.on('streamAdded', on_streamAdded)\n      conversation.on('streamRemoved', on_streamRemoved)\n      conversation.on('streamListChanged', on_streamListChanged)\n\n      return () => {\n        // remove listeners\n        conversation.removeListener('streamListChanged', on_streamListChanged)\n        conversation.removeListener('streamRemoved', on_streamRemoved)\n        conversation.removeListener('streamAdded', on_streamAdded)\n      }\n    }\n  }, [conversation])\n\n  const unpublishAndUnsubscribeAll = (i_conversation: Conversation) => {\n    publishedStreams.forEach(stream => {\n      if (globalThis.apirtcReactLibLogLevel.isDebugEnabled) {\n        console.debug(HOOK_NAME + \"|unpublish stream\", i_conversation, stream)\n      }\n      i_conversation.unpublish(stream)\n    })\n    // Clear internal array\n    publishedStreams.length = 0;\n\n    // Clear cache\n    setPublishedStreamsCache([])\n\n    subscribedStreams.forEach(stream => {\n      if (globalThis.apirtcReactLibLogLevel.isDebugEnabled) {\n        console.debug(HOOK_NAME + \"|unsubscribeToStream stream\", i_conversation, stream)\n      }\n      i_conversation.unsubscribeToStream(stream.getId())\n    })\n    // Clear internal array\n    subscribedStreams.length = 0;\n\n    // Clear output arrays with new array so that parent gets notified of a change.\n    // Simply setting length to 0 is not detected by react.\n    setO_PublishedStreams(new Array<Stream>())\n    setO_SubscribedStreams(new Array<Stream>())\n  };\n\n  useEffect(() => {\n    if (conversation) {\n      if (globalThis.apirtcReactLibLogLevel.isDebugEnabled) {\n        console.debug(HOOK_NAME + \"|useEffect doHandlePublication\", conversation.getName())\n      }\n\n      const on_joined = () => {\n        if (globalThis.apirtcReactLibLogLevel.isInfoEnabled) {\n          console.info(HOOK_NAME + \"|on_joined\", conversation.getName(), streamsToPublish)\n        }\n        doHandlePublication()\n      };\n      const on_left = () => {\n        if (globalThis.apirtcReactLibLogLevel.isInfoEnabled) {\n          console.info(HOOK_NAME + \"|on_left\", conversation.getName())\n        }\n        // Forcing unpublish will allow to republish if joining again\n        unpublishAndUnsubscribeAll(conversation)\n      };\n\n      conversation.on('joined', on_joined)\n      conversation.on('left', on_left)\n\n      return () => {\n        conversation.removeListener('joined', on_joined)\n        conversation.removeListener('left', on_left)\n      }\n    }\n  }, [doHandlePublication]) // Don't add 'conversation' in here because\n  // doHandlePublication already changes on conversation change\n\n  // subscribeToStream(s) after having set listeners\n  //\n  useEffect(() => {\n    if (conversation) {\n      if (globalThis.apirtcReactLibLogLevel.isDebugEnabled) {\n        console.debug(`${HOOK_NAME}|conversation|${conversation.getName()}`, conversation)\n      }\n      // Subscribe to existing remote streams\n      conversation.getAvailableStreamList().forEach((streamInfo: StreamInfo) => {\n        const streamId = String(streamInfo.streamId);\n        if (streamInfo.isRemote === true) {\n          conversation.subscribeToStream(streamId)\n        }\n      })\n      return () => {\n        unpublishAndUnsubscribeAll(conversation)\n      }\n    }\n  }, [conversation])\n\n  useEffect(() => {\n    if (globalThis.apirtcReactLibLogLevel.isDebugEnabled) {\n      console.debug(`${HOOK_NAME}|streamsToPublish`,\n        JSON.stringify(streamsToPublish.map(l_s => l_s?.stream.getId() + '-' + JSON.stringify(l_s?.options))))\n    }\n    if (conversation && conversation.isJoined()) {\n      doHandlePublication()\n    }\n  }, [JSON.stringify(streamsToPublish.map(l_s => l_s?.stream.getId() + '-' + JSON.stringify(l_s?.options)))])\n\n  return {\n    publishedStreams: o_publishedStreams,\n    subscribedStreams: o_subscribedStreams,\n    publish,\n    unpublish,\n    replacePublishedStream\n  }\n}\n","import { useState, useEffect } from 'react'\nimport { Session, Contact } from '@apirtc/apirtc'\n\n/**\n * Subscribe to groups and returns contactsByGroup (of theses groups only) when updated.\n * If input groups list is updated, this hooks works diff with the previous set in order\n * to make as little as possible unsubscribe/subscribe calls.\n */\n\nconst HOOK_NAME = \"usePresence\";\nexport default function usePresence(session: Session | undefined, groups: Array<string>) {\n\n    const [groupsCache] = useState<Set<string>>(new Set());\n\n    const [m_contactsByGroup] = useState<Map<string, Set<Contact>>>(new Map());\n\n    const [contactsByGroup, setContactsByGroup] = useState<Map<string, Set<Contact>>>(new Map());\n\n    useEffect(() => {\n        if (session) {\n            return () => {\n                m_contactsByGroup.clear()\n                setContactsByGroup(new Map(m_contactsByGroup))\n                groupsCache.clear()\n            }\n        }\n    }, [session])\n\n    const getOrCreateGroupSet = (group: string) => {\n        const o_set = m_contactsByGroup.get(group) ?? new Set();\n        if (!m_contactsByGroup.has(group)) {\n            m_contactsByGroup.set(group, o_set)\n        }\n        return o_set\n    };\n\n    useEffect(() => {\n        if (globalThis.apirtcReactLibLogLevel.isDebugEnabled) {\n            console.debug(HOOK_NAME + \"|useEffect session, groups\", groups)\n        }\n        if (session) {\n            const l_session = session;\n            const l_groupsSet = new Set(groups);\n\n            // Diff update subscription to groups\n            //\n            l_groupsSet.forEach(group => {\n                if (!groupsCache.has(group)) {\n                    if (globalThis.apirtcReactLibLogLevel.isInfoEnabled) {\n                        console.info(HOOK_NAME + \"|subscribeToGroup\", group)\n                    }\n                    groupsCache.add(group)\n                    l_session.subscribeToGroup(group)\n                }\n            })\n\n            let needsRefresh = false;\n            groupsCache.forEach(group => {\n                if (!l_groupsSet.has(group)) {\n                    if (globalThis.apirtcReactLibLogLevel.isInfoEnabled) {\n                        console.info(HOOK_NAME + \"|unsubscribeToGroup\", group)\n                    }\n                    l_session.unsubscribeToGroup(group)\n                    groupsCache.delete(group)\n                    m_contactsByGroup.delete(group)\n                    needsRefresh = true;\n                }\n            })\n\n            if (needsRefresh) {\n                // contactsByGroup is exposed, so change the Map object to let client code detect a change.\n                setContactsByGroup(new Map(m_contactsByGroup))\n            }\n\n            if (groups.length > 0) {\n                const onContactListUpdate = (updatedContacts: any) => {\n\n                    if (globalThis.apirtcReactLibLogLevel.isDebugEnabled) {\n                        console.debug(HOOK_NAME + \"|contactListUpdate\", updatedContacts)\n                    }\n\n                    let needsRefresh = false;\n\n                    // Maintain Map of Contacts per Group\n                    //\n                    for (const group of Object.keys(updatedContacts.joinedGroup)) {\n                        if (l_groupsSet.has(group)) {\n                            const l_set = getOrCreateGroupSet(group);\n                            for (const contact of updatedContacts.joinedGroup[group]) {\n                                l_set.add(contact)\n                                needsRefresh = true;\n                            }\n                        }\n                    }\n                    for (const group of Object.keys(updatedContacts.leftGroup)) {\n                        if (l_groupsSet.has(group)) {\n                            const l_set = getOrCreateGroupSet(group);\n                            for (const contact of updatedContacts.leftGroup[group]) {\n                                l_set.delete(contact)\n                                needsRefresh = true;\n\n                                // if set is empty, no need to keep the group as key in the map\n                                if (l_set.size === 0) {\n                                    m_contactsByGroup.delete(group)\n                                }\n                            }\n                        }\n                    }\n\n                    // For data updates, trigger a refresh if and only if contact is part of managed groups\n                    for (const contact of updatedContacts.userDataChanged as Contact[]) {\n                        for (const l_contacts of m_contactsByGroup.values()) {\n                            if (l_contacts.has(contact)) {\n                                needsRefresh = true;\n                                break;\n                            }\n                        }\n                    }\n\n                    if (needsRefresh) {\n                        // contactsByGroup is exposed, so change the Map object to let client code detect a change.\n                        setContactsByGroup(new Map(m_contactsByGroup))\n                    }\n                };\n                l_session.on('contactListUpdate', onContactListUpdate)\n                return () => {\n                    l_session.removeListener('contactListUpdate', onContactListUpdate)\n                }\n            }\n        }\n    }, [session, JSON.stringify(groups)])\n\n    return {\n        contactsByGroup\n    }\n}","import { useEffect, useState } from 'react'\nimport { Session, UserAgent, RegisterInformation } from '@apirtc/apirtc'\n\ntype LoginPassword = {\n    username: string\n    password: string\n};\n\nfunction isInstanceOfLoginPassword(object: any): object is LoginPassword {\n    if (typeof object !== 'object') return false;\n    return 'username' in object;\n}\n\ntype ApiKey = { apiKey: string };\nfunction isInstanceOfApiKey(object: any): object is ApiKey {\n    if (typeof object !== 'object') return false;\n    return 'apiKey' in object;\n}\n\ntype Token = { token: string };\nfunction isInstanceOfToken(object: any): object is Token {\n    if (typeof object !== 'object') return false;\n    return 'token' in object;\n}\n\nexport type Credentials = LoginPassword | ApiKey | Token;\n\nconst HOOK_NAME = \"useSession\";\nexport default function useSession(credentials?: Credentials, options?: RegisterInformation) {\n\n    const [session, setSession] = useState<Session | undefined>()\n    const [connecting, setConnecting] = useState<boolean>(false)\n    const [error, setError] = useState<any>()\n\n    useEffect(() => {\n        if (globalThis.apirtcReactLibLogLevel.isDebugEnabled) {\n            console.debug(HOOK_NAME + \"|useEffect credentials, options\", credentials, options)\n        }\n        if (credentials) {\n            // To fix errors like \"Warning: Can't perform a React state update on an unmounted component\"\n            // https://stackoverflow.com/questions/53949393/cant-perform-a-react-state-update-on-an-unmounted-component\n            let isMounted = true;\n            connect(credentials, options).catch((error: any) => {\n                console.error(HOOK_NAME + \"|connection failed\", error, isMounted)\n                setSession(undefined)\n                if (isMounted) {\n                    setError(error)\n                }\n            })\n            return () => {\n                isMounted = false;\n                setSession(undefined)\n                // Even though connecting is managed in connect(),\n                // mark connecting to false when credentials are changed\n                // as this shall be way to connect elsewhere or connect to\n                // with other credentials. Note that to be perfect we should\n                // cancel the potentially running connect : Is that possible with ApiRTC ?\n                setConnecting(false)\n                setError(undefined)\n            }\n        }\n    }, [JSON.stringify(credentials), JSON.stringify(options)])\n\n    useEffect(() => {\n        if (globalThis.apirtcReactLibLogLevel.isDebugEnabled) {\n            console.debug(HOOK_NAME + \"|useEffect session\", session)\n        }\n        if (session) {\n            const l_session = session;\n            return () => {\n                l_session.disconnect().then(() => {\n                    if (globalThis.apirtcReactLibLogLevel.isInfoEnabled) {\n                        console.info(HOOK_NAME + \"|disconnected\", l_session)\n                    }\n                }).catch((error: any) => {\n                    console.error(HOOK_NAME + \"|disconnect\", error)\n                })\n            }\n        }\n    }, [session])\n\n    const connect = (credentials: Credentials | undefined, options?: RegisterInformation) => {\n        return new Promise<void>((resolve, reject) => {\n            const registerInformation: RegisterInformation = options ? options : {\n                cloudUrl: 'https://cloud.apirtc.com',\n            };\n\n            let l_userAgent;\n\n            if (isInstanceOfLoginPassword(credentials)) {\n                registerInformation.password = credentials.password;\n                l_userAgent = new UserAgent({\n                    uri: 'apirtc:' + credentials.username\n                });\n            } else if (isInstanceOfApiKey(credentials)) {\n                l_userAgent = new UserAgent({\n                    uri: `apiKey:${credentials.apiKey}`\n                });\n            } else if (isInstanceOfToken(credentials)) {\n                l_userAgent = new UserAgent({\n                    uri: `token:${credentials.token}`\n                });\n            } else {\n                reject(\"credentials not recognized\")\n                return\n            }\n\n            setConnecting(true)\n            l_userAgent.register(registerInformation).then(l_session => {\n                if (globalThis.apirtcReactLibLogLevel.isInfoEnabled) {\n                    console.info(HOOK_NAME + \"|connected\", l_session)\n                }\n                setSession(l_session)\n                resolve()\n            }).catch((error: any) => {\n                reject(error)\n            }).finally(() => {\n                setConnecting(false)\n            })\n        })\n    }\n\n    // const disconnect = useCallback(() => {\n    //     return new Promise<void>((resolve, reject) => {\n    //         if (session) {\n    //             const l_session = session;\n    //             l_session.disconnect().then(() => {\n    //                 console.log(HOOK_NAME + \"|disconnected\", l_session)\n    //                 setSession(undefined)\n    //                 resolve()\n    //             }).catch((error: any) => {\n    //                 console.error(HOOK_NAME + \"|disconnect\", error)\n    //                 reject(error)\n    //             })\n    //         } else {\n    //             resolve()\n    //         }\n    //     })\n    // }, [session])\n\n    const disconnect = () => {\n        setSession(undefined)\n    };\n\n    return {\n        //userAgent: userAgent, // can get it from session\n        session: session,\n        connecting,\n        connect,\n        disconnect,\n        error\n    }\n}\n","import { useState, useEffect, useCallback } from 'react'\nimport { Stream, VideoProcessorOptions } from '@apirtc/apirtc'\n\nconst HOOK_NAME = \"useStreamApplyVideoProcessor\";\n/**\n * This hook takes stream passed as parameter, and\n * returns either this stream or a stream with video processor applied.\n * This is controlled by the videoProcessorType input attribute.\n * By default the output stream is the input stream.\n * The hook fully manages the output stream (applies 'none' if input stream is set to undefined).\n * The hook never releases the input stream.\n * \n * @param stream \n * @returns stream blurred or not, toggle method, boolean blurred state.\n */\nexport default function useStreamApplyVideoProcessor(\n    stream: Stream | undefined,\n    videoProcessorType: 'none' | 'blur' | 'backgroundImage', options?: VideoProcessorOptions,\n    errorCallback?: (error: any) => void) {\n    //\n    const [outStream, setOutStream] = useState(stream);\n    const [applied, setApplied] = useState<'none' | 'blur' | 'backgroundImage'>('none')\n\n    useEffect(() => {\n        if (globalThis.apirtcReactLibLogLevel.isDebugEnabled) {\n            console.debug(HOOK_NAME + \"|useEffect\", stream, videoProcessorType, options)\n        }\n        if (stream && videoProcessorType !== 'none') {\n            stream.applyVideoProcessor(videoProcessorType, options).then(l_stream => {\n                setOutStream(l_stream)\n                setApplied(videoProcessorType)\n            }).catch(error => {\n                setOutStream(stream)\n                if (errorCallback) {\n                    errorCallback(error)\n                } else if (globalThis.apirtcReactLibLogLevel.isWarnEnabled) {\n                    console.warn(HOOK_NAME + \"|useEffect\", stream, videoProcessorType, options, error)\n                }\n                setApplied(previousValue => previousValue)\n            })\n        } else {\n            setOutStream(stream)\n            setApplied('none')\n        }\n    }, [stream, videoProcessorType, options])\n\n    const doCheckAndReleaseOutStream = useCallback(() => {\n        if (outStream && (outStream !== stream)) {\n            if (globalThis.apirtcReactLibLogLevel.isDebugEnabled) {\n                console.debug(HOOK_NAME + \"|releasing outStream\", outStream)\n            }\n            // stream?.applyVideoProcessor('none').catch(error => {\n            //     if (globalThis.apirtcReactLibLogLevel.isWarnEnabled) {\n            //         console.warn(HOOK_NAME + \"|doCheckAndReleaseOutStream\", stream, outStream)\n            //     }\n            // })\n            outStream.release()\n        }\n    }, [stream, outStream])\n\n    useEffect(() => {\n        return () => {\n            doCheckAndReleaseOutStream()\n        }\n    }, [outStream])\n\n    return {\n        stream: outStream,\n        applied\n    }\n}","import { useState, useEffect } from 'react'\nimport { MediaDeviceList, Session, UserAgent } from '@apirtc/apirtc'\n\nconst EMPTY_LIST: MediaDeviceList = { audioinput: {}, audiooutput: {}, videoinput: {} }\n\nconst HOOK_NAME = \"useUserMediaDevices\";\nexport default function useUserMediaDevices(\n    session: Session | undefined\n) {\n    const [userMediaDevices, setUserMediaDevices] = useState<MediaDeviceList>(EMPTY_LIST)\n\n    useEffect(() => {\n        if (session) {\n            const userAgent: UserAgent = session.getUserAgent();\n\n            const on_mediaDeviceChanged = () => {\n                const mediaDevices: MediaDeviceList = userAgent.getUserMediaDevices()\n                if (globalThis.apirtcReactLibLogLevel.isInfoEnabled) {\n                    console.info(HOOK_NAME + \"|mediaDeviceChanged\", mediaDevices)\n                }\n                setUserMediaDevices(mediaDevices)\n            };\n            userAgent.on(\"mediaDeviceChanged\", on_mediaDeviceChanged)\n\n            return () => {\n                userAgent.removeListener('mediaDeviceChanged', on_mediaDeviceChanged)\n                setUserMediaDevices(EMPTY_LIST)\n            }\n        }\n    }, [session])\n\n    return {\n        userMediaDevices\n    }\n}","export * from './components'\nexport * from './hooks'\n\ntype LogLevel = {\n    level: 'debug' | 'info' | 'warn' | 'error'\n    isDebugEnabled: boolean\n    isInfoEnabled: boolean\n    isWarnEnabled: boolean\n}\n\nconst INFO: LogLevel = { level: 'info', isDebugEnabled: false, isInfoEnabled: true, isWarnEnabled: true };\n\ndeclare global {\n    var apirtcReactLibLogLevel: LogLevel;\n    var setApirtcReactLibLogLevel: Function;\n}\n\n// a default value MUST be set in case application using the library does not override it\nglobalThis.apirtcReactLibLogLevel = INFO;\n\nexport function setLogLevel(logLevelText: 'debug' | 'info' | 'warn' | 'error' | string) {\n    switch (logLevelText) {\n        case 'debug':\n            globalThis.apirtcReactLibLogLevel = { level: 'debug', isDebugEnabled: true, isInfoEnabled: true, isWarnEnabled: true };\n            break\n        case 'info':\n            globalThis.apirtcReactLibLogLevel = INFO;\n            break\n        case 'warn':\n            globalThis.apirtcReactLibLogLevel = { level: 'warn', isDebugEnabled: false, isInfoEnabled: false, isWarnEnabled: true };\n            break\n        case 'error':\n            globalThis.apirtcReactLibLogLevel = { level: 'error', isDebugEnabled: false, isInfoEnabled: false, isWarnEnabled: false };\n            break\n        default:\n            // in case null is passed as input, default to 'info'\n            globalThis.apirtcReactLibLogLevel = INFO;\n    }\n    return globalThis.apirtcReactLibLogLevel\n}\n\nglobalThis.setApirtcReactLibLogLevel = setLogLevel;\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}