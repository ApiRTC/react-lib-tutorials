{"version":3,"file":"react-lib.production.min.js","sources":["../src/hooks/useCameraStream.ts","../src/hooks/useConversation.ts","../src/hooks/useConversationMessages.ts","../src/hooks/useConversationModeration.ts","../src/hooks/useConversationStreams.ts","../src/hooks/usePresence.ts","../src/hooks/useSession.ts","../src/hooks/useStreamApplyVideoProcessor.ts","../src/hooks/useUserMediaDevices.ts","../src/index.ts","../src/components/VideoStream/VideoStream.tsx"],"sourcesContent":["import { useState, useEffect } from 'react'\nimport { CreateStreamOptions, Session, Stream, UserAgent } from '@apirtc/apirtc'\n\nconst HOOK_NAME = \"useCameraStream\";\nexport default function useCameraStream(\n    session: Session | undefined,\n    options: CreateStreamOptions = {}\n) {\n    const [stream, setStream] = useState<Stream>();\n\n    useEffect(() => {\n        if (session) {\n            const userAgent: UserAgent = session.getUserAgent();\n            userAgent.createStream(options).then((localStream: Stream) => {\n                if (globalThis.apirtcReactLibLogLevel.isInfoEnabled) {\n                    console.info(HOOK_NAME + \"|createStream\", options, localStream)\n                }\n                setStream(localStream)\n            }).catch((error: any) => {\n                console.error(HOOK_NAME + \"|createStream\", options, error)\n                setStream(undefined)\n            })\n\n            // DO NOT set out stream to undefined in the return, to prevent unnecessary refreshes\n            // of other components with undefined stream, whereas we are expecting to change it\n            // to another instance..\n            // return () => { setStream(undefined) } // DON'T\n        } else {\n            setStream(undefined)\n        }\n\n    }, [session, JSON.stringify(options)])\n\n    useEffect(() => {\n        return () => {\n            if (stream) {\n                if (globalThis.apirtcReactLibLogLevel.isInfoEnabled) {\n                    console.info(HOOK_NAME + \"|release stream\", stream)\n                }\n                stream.release()\n            }\n        }\n    }, [stream])\n\n    return {\n        stream\n    }\n}","import { useState, useEffect, useCallback } from 'react'\nimport { Conversation, GetOrCreateConversationOptions, Session } from '@apirtc/apirtc'\n\nconst HOOK_NAME = \"useConversation\";\n/**\n * Please note that the hook won't react on autoJoin change\n */\nexport default function useConversation(\n    session: Session | undefined,\n    name: string | undefined,\n    options?: GetOrCreateConversationOptions,\n    join: boolean = false\n) {\n    const [conversation, setConversation] = useState<Conversation>();\n    const [joined, setJoined] = useState<boolean>(false);\n    const [joining, setJoining] = useState<boolean>(false);\n\n    // Callbacks\n    //\n    // Offering Promised join/leave methods allows developer to act on then/catch\n    //\n    const o_join = useCallback(() => {\n        if (globalThis.apirtcReactLibLogLevel.isDebugEnabled) {\n            console.debug(HOOK_NAME + \"|join\", conversation)\n            //JSON.stringify((apiRTC as any).session.apiCCWebRTCClient.webRTCClient.MCUClient.sessionMCUs))\n        }\n        return new Promise<void>((resolve, reject) => {\n            if (!conversation) {\n                reject(HOOK_NAME + \"|join|conversation not defined\")\n                return\n            }\n            if (!conversation.isJoined()) {\n                setJoining(true)\n                conversation.join().then(() => {\n                    // successfully joined the conversation.\n                    setJoined(true)\n                    resolve()\n                }).catch((error: any) => {\n                    // could not join the conversation.\n                    reject(error)\n                }).finally(() => {\n                    setJoining(false)\n                })\n            } else {\n                reject(HOOK_NAME + \"|join|conversation already joined\")\n            }\n        })\n    }, [conversation]);\n\n    const o_leave = useCallback(() => {\n        if (globalThis.apirtcReactLibLogLevel.isDebugEnabled) {\n            console.debug(HOOK_NAME + \"|leave\", conversation)\n        }\n        return new Promise<void>((resolve, reject) => {\n            if (!conversation) {\n                reject(HOOK_NAME + \"|leave|conversation not defined\")\n                return\n            }\n            if (conversation.isJoined()) {\n                conversation.leave().then(() => {\n                    // local user successfully left the conversation.\n                    setJoined(false)\n                    resolve()\n                }).catch((error: any) => {\n                    reject(error)\n                })\n            } else {\n                reject(HOOK_NAME + \"|leave|conversation is not joined\")\n            }\n        })\n    }, [conversation]);\n\n    // Effects\n    //\n    useEffect(() => {\n        if (session && name) {\n            if (globalThis.apirtcReactLibLogLevel.isDebugEnabled) {\n                console.debug(HOOK_NAME + \"|getOrCreateConversation\", name, options, join)\n            }\n            const l_conversation = session.getOrCreateConversation(name, options);\n            setConversation(l_conversation)\n            return () => {\n                if (globalThis.apirtcReactLibLogLevel.isDebugEnabled) {\n                    console.debug(HOOK_NAME + \"|useEffect cleanup\", name, options, join)\n                }\n                if (l_conversation.isJoined()) {\n                    l_conversation.leave()\n                        .then(() => { })\n                        .catch((error: any) => {\n                            if (globalThis.apirtcReactLibLogLevel.isWarnEnabled) {\n                                console.warn(HOOK_NAME + \"|useEffect conversation.leave()\", error)\n                            }\n                        })\n                        .finally(() => {\n                            l_conversation.destroy()\n                            setConversation(undefined)\n                            setJoined(false)\n                        })\n                } else {\n                    // It is important to destroy the conversation.\n                    // Otherwise subsequent getOrCreateConversation with same name would get\n                    // previous handle, regardless of the potentially new options.\n                    // This also allows to cleanup memory\n                    l_conversation.destroy()\n                    setConversation(undefined)\n                }\n            }\n        }\n    }, [session, name, JSON.stringify(options)])\n\n    useEffect(() => {\n        if (conversation && join) {\n            if (globalThis.apirtcReactLibLogLevel.isDebugEnabled) {\n                console.debug(HOOK_NAME + \"|useEffect\", conversation, join)\n            }\n            const l_conversation = conversation;\n            const l_join = join;\n            if (l_join) {\n                setJoining(true)\n                l_conversation.join().then(() => {\n                    if (globalThis.apirtcReactLibLogLevel.isInfoEnabled) {\n                        console.info(HOOK_NAME + \"|joined\", l_conversation)\n                    }\n                    setJoined(true)\n                }).catch((error: any) => {\n                    if (globalThis.apirtcReactLibLogLevel.isWarnEnabled) {\n                        console.warn(HOOK_NAME + \"|useEffect conversation.join()\", error)\n                    }\n                }).finally(() => {\n                    setJoining(false)\n                })\n            }\n            return () => {\n                if (globalThis.apirtcReactLibLogLevel.isDebugEnabled) {\n                    console.debug(HOOK_NAME + \"|useEffect cleanup\", l_conversation, l_join)\n                }\n                if (l_conversation.isJoined()) {\n                    l_conversation.leave().then(() => {\n                        setJoined(false)\n                    }).catch((error: any) => {\n                        if (globalThis.apirtcReactLibLogLevel.isWarnEnabled) {\n                            console.warn(HOOK_NAME + \"|useEffect conversation.leave()\", error)\n                        }\n                    })\n                }\n            }\n        }\n    }, [conversation, join])\n\n    return {\n        conversation,\n        joining,\n        joined,\n        join: o_join,\n        leave: o_leave\n    }\n}","import { useState, useEffect, useCallback } from 'react'\nimport { Contact, Conversation, ConversationMessage } from '@apirtc/apirtc'\n\n// TODO : get and handle with pagination messages history\n// TODO : ask apirtc to include the uuid in ConversationMessage so that we can store it\n// into ConversationMessage when creating the local one, and we get it from conversation on:message\n// the uuid shall be the value used as a react child key when displaying list of messages\n\nconst HOOK_NAME = \"useConversationMessages\";\nexport default function useConversationMessages(\n    conversation: Conversation | undefined,\n) {\n    // Use an internal array which will always be the same object as far as React knows\n    // This will avoid the need for adding it as a dependency for each callback\n    const [messages] = useState<Array<ConversationMessage>>(new Array<ConversationMessage>());\n    // And use a copy as output array so that client code will react upon change\n    // (only a new instance of array is detected by React)\n    const [o_messages, setO_Messages] = useState<Array<ConversationMessage>>(new Array<ConversationMessage>());\n\n    useEffect(() => {\n        if (conversation) {\n            const onMessage = (message: ConversationMessage) => {\n                if (globalThis.apirtcReactLibLogLevel.isInfoEnabled) {\n                    console.info(HOOK_NAME + \"|on:message:\", conversation.getName(), message)\n                }\n                messages.push(message)\n                setO_Messages(Array.from(messages))\n            };\n            conversation.on('message', onMessage)\n\n            return () => {\n                conversation.removeListener('message', onMessage)\n                messages.length = 0;\n                setO_Messages(new Array<any>())\n            }\n        }\n    }, [conversation])\n\n    const sendMessage = useCallback((msgContent: string, sender: Contact) => {\n        return new Promise<void>((resolve, reject) => {\n            conversation?.sendMessage(msgContent)\n                .then((uuid: number) => {\n                    if (globalThis.apirtcReactLibLogLevel.isInfoEnabled) {\n                        console.info(HOOK_NAME + \"|sentMessage\", conversation.getName(), uuid, msgContent)\n                    }\n                    messages.push({ content: msgContent, sender: sender, time: new Date() })\n                    setO_Messages(Array.from(messages))\n                    resolve()\n                })\n                .catch((error: any) => {\n                    if (globalThis.apirtcReactLibLogLevel.isWarnEnabled) {\n                        console.warn(HOOK_NAME + \"|sendMessage error\", error)\n                    }\n                    reject(error)\n                })\n        })\n    }, [conversation]);\n\n    return {\n        messages: o_messages,\n        sendMessage\n    }\n}","import { useState, useEffect } from 'react'\nimport { Contact, Conversation } from '@apirtc/apirtc'\n\nconst HOOK_NAME = \"useConversationModeration\";\nexport default function useConversationModeration(\n    conversation: Conversation | undefined,\n    onEjected?: (contact: Contact) => void,\n    onEjectedSelf?: () => void) {\n\n    const [candidates, setCandidates] = useState<Set<Contact>>(new Set<Contact>());\n\n    useEffect(() => {\n        if (globalThis.apirtcReactLibLogLevel.isDebugEnabled) {\n            console.debug(HOOK_NAME + \"|useEffect conversation\", conversation)\n        }\n\n        if (conversation) {\n            const on_contactJoinedWaitingRoom = (contact: Contact) => {\n                if (globalThis.apirtcReactLibLogLevel.isInfoEnabled) {\n                    console.info(HOOK_NAME + \"|on:contactJoinedWaitingRoom\", contact)\n                }\n                // A candidate joined the waiting room.\n                candidates.add(contact)\n                setCandidates(new Set(candidates))\n            };\n            const on_contactLeftWaitingRoom = (contact: Contact) => {\n                if (globalThis.apirtcReactLibLogLevel.isInfoEnabled) {\n                    console.info(HOOK_NAME + \"|on:contactLeftWaitingRoom\", contact)\n                }\n                // A candidate left the waiting room.\n                candidates.delete(contact)\n                setCandidates(new Set(candidates))\n            };\n            // TODO make apirtc.d.ts update to replace 'any'\n            const on_participantEjected = (data: any) => {\n                if (globalThis.apirtcReactLibLogLevel.isInfoEnabled) {\n                    console.info(HOOK_NAME + \"|on:participantEjected\", data)\n                }\n                if (data.self === true) {\n                    if (globalThis.apirtcReactLibLogLevel.isInfoEnabled) {\n                        console.info(HOOK_NAME + \"|Self participant was ejected\")\n                    }\n                    if (onEjectedSelf) {\n                        onEjectedSelf()\n                    }\n                } else {\n                    if (onEjected) {\n                        onEjected(data.contact)\n                    }\n                }\n            };\n\n            conversation\n                .on('contactJoinedWaitingRoom', on_contactJoinedWaitingRoom)\n                .on('contactLeftWaitingRoom', on_contactLeftWaitingRoom)\n                .on('participantEjected', on_participantEjected)\n\n            return () => {\n                if (globalThis.apirtcReactLibLogLevel.isDebugEnabled) {\n                    console.debug(HOOK_NAME + \"|conversation clear\", conversation)\n                }\n                // remove listeners\n                conversation\n                    .removeListener('contactJoinedWaitingRoom', on_contactJoinedWaitingRoom)\n                    .removeListener('contactLeftWaitingRoom', on_contactLeftWaitingRoom)\n                    .removeListener('participantEjected', on_participantEjected)\n                setCandidates(new Set())\n            }\n        }\n    }, [conversation])\n\n    return {\n        candidates\n    }\n}","import { useState, useEffect, useCallback } from 'react'\nimport { Conversation, PublishOptions, Stream, StreamInfo } from '@apirtc/apirtc'\n\n// TODO?: add pagination ?\n// interface Options {\n//   streamsSubscribePageSize: number\n// }\n\nfunction notEmpty<T>(value: T | null | undefined): value is T {\n  return value !== null && value !== undefined;\n}\n\nconst HOOK_NAME = \"useConversationStreams\";\nexport default function useConversationStreams(\n  conversation: Conversation | undefined,\n  /** fully managed list of Stream(s) to publish, with associated publish options */\n  streamsToPublish: Array<{ stream: Stream, options?: PublishOptions } | undefined | null> = [],\n  errorCallback?: (error: any) => void\n) {\n\n  if (globalThis.apirtcReactLibLogLevel.isDebugEnabled) {\n    console.debug(`${HOOK_NAME}|hook`)\n  }\n\n  // A cache to handle publication differences\n  const [publishedStreamsCache, setPublishedStreamsCache] =\n    useState<Array<{ stream: Stream, options?: PublishOptions } | undefined | null>>([]);\n\n  // Use an internal array which will always be the same object as far as React knows\n  // This will avoid the need for adding it as a dependency for each callback\n  const [publishedStreams] = useState<Array<Stream>>(new Array<Stream>());\n  // And use a copy as output array so that client code will react upon change\n  // (only a new instance of array is detected by React)\n  const [o_publishedStreams, setO_PublishedStreams] = useState<Array<Stream>>(new Array<Stream>());\n\n  const [subscribedStreams] = useState<Array<Stream>>(new Array<Stream>());\n  const [o_subscribedStreams, setO_SubscribedStreams] = useState<Array<Stream>>(new Array<Stream>());\n\n  const publish: (localStream: Stream, options?: PublishOptions) => Promise<Stream> =\n    useCallback((localStream: Stream, options?: PublishOptions) => {\n      return new Promise<Stream>((resolve, reject) => {\n        if (conversation) {\n          if (globalThis.apirtcReactLibLogLevel.isDebugEnabled) {\n            console.debug(`${HOOK_NAME}|publish|${conversation.getName()}`, localStream, options)\n          }\n          conversation.publish(localStream, options).then((stream: Stream) => {\n            if (globalThis.apirtcReactLibLogLevel.isInfoEnabled) {\n              console.info(`${HOOK_NAME}|published|${conversation.getName()}`, stream)\n            }\n            //console.log(`PUSHING ${stream.getId()} to publishedStreams`, JSON.stringify(publishedStreams.map(s => s.getId())))\n            publishedStreams.push(stream)\n            // Returning a new array makes lets React detect changes\n            setO_PublishedStreams(Array.from(publishedStreams))\n            resolve(stream)\n          }).catch((error: any) => {\n            reject(error)\n          })\n        }\n      })\n    }, [conversation]);\n\n  const replacePublishedStream = useCallback((oldStream: Stream, newStream: Stream, options?: PublishOptions) => {\n    return new Promise<Stream>((resolve, reject) => {\n      if (conversation) {\n        if (globalThis.apirtcReactLibLogLevel.isDebugEnabled) {\n          console.debug(`${HOOK_NAME}|replacePublishedStream|${conversation.getName()}|${oldStream.getId()} -> ${newStream.getId()}(${JSON.stringify(options)})`)\n        }\n        const conversationCall = conversation.getConversationCall(oldStream);\n        if (conversationCall) {\n          conversationCall.replacePublishedStream(newStream, undefined, options)\n            .then((stream: Stream) => {\n              if (globalThis.apirtcReactLibLogLevel.isInfoEnabled) {\n                console.info(`${HOOK_NAME}|stream replaced|${conversation.getName()}`, oldStream, stream, options)\n              }\n              const index = publishedStreams.indexOf(oldStream);\n              if (index >= 0) {\n                publishedStreams.splice(index, 1, stream)\n                setO_PublishedStreams(Array.from(publishedStreams))\n              }\n              resolve(stream)\n            }).catch((error: any) => {\n              reject(error)\n            })\n        }\n      }\n    })\n  }, [conversation]);\n\n  const unpublish: (localStream: Stream) => void = useCallback((localStream: Stream) => {\n    if (conversation) {\n      if (globalThis.apirtcReactLibLogLevel.isDebugEnabled) {\n        console.debug(`${HOOK_NAME}|unpublish|${conversation.getName()}`, localStream)\n      }\n      conversation.unpublish(localStream)\n      const index = publishedStreams.indexOf(localStream);\n      if (index >= 0) {\n        publishedStreams.splice(index, 1)\n        setO_PublishedStreams(Array.from(publishedStreams))\n      }\n    }\n  }, [conversation]);\n\n  const doHandlePublication = useCallback(() => {\n    const maxLength = Math.max(publishedStreamsCache.length, streamsToPublish.length);\n    if (globalThis.apirtcReactLibLogLevel.isDebugEnabled) {\n      console.debug(HOOK_NAME + \"|doHandlePublication\", streamsToPublish,\n        JSON.stringify(publishedStreamsCache.map(l_s => l_s?.stream.getId())), maxLength)\n    }\n\n    // Strategy for published streams cache is to initialize it as it should be\n    // and remove items if publication fails.\n    const newPublishedStreamsCache = [...streamsToPublish];\n    setPublishedStreamsCache(newPublishedStreamsCache)\n\n    // Prepare a set for Streams to publish, for further optimized check\n    const streamsToPublishSet = new Set(streamsToPublish.filter(notEmpty).map((item) => item.stream));\n\n    // Loop on arrays index to publish new streams, or replace if necessary\n    for (let i = 0; i < maxLength; i++) {\n      const previous = publishedStreamsCache[i];\n      const next = streamsToPublish[i];\n\n      if (previous && next) {\n        const doReplacePublishedStream = () => {\n          replacePublishedStream(previous.stream, next.stream, next.options)\n            .catch((error: Error) => {\n              newPublishedStreamsCache.splice(i, 1, null)\n              if (errorCallback) {\n                errorCallback(error)\n              } else if (globalThis.apirtcReactLibLogLevel.isWarnEnabled) {\n                console.warn(`${HOOK_NAME}|replacePublishedStream|error`, error)\n              }\n            })\n        }\n        if (previous.stream === next.stream) {\n          // Streams are the same, only replace if options are different\n          if (JSON.stringify(previous.options) !== JSON.stringify(next.options)) {\n            doReplacePublishedStream()\n          }\n        } else {\n          // If position in both new and cached list are defined but are different:\n          // replace if and only if stream to unpublish shall not be published (at other position)\n          if (streamsToPublishSet.has(previous.stream)) { // previous shall be published\n            // Previous shall actually be published (at another position), so don't do anything about it\n            // But then we still have to publish new stream (if not already published)\n            if (conversation && !conversation.isPublishedStream(next.stream)) {\n              publish(next.stream, next.options).catch((error: Error) => {\n                newPublishedStreamsCache.splice(i, 1, null)\n                if (errorCallback) {\n                  errorCallback(error)\n                } else if (globalThis.apirtcReactLibLogLevel.isWarnEnabled) {\n                  console.warn(`${HOOK_NAME}|publish|error`, error)\n                }\n              })\n            }\n          } else {\n            if (conversation && !conversation.isPublishedStream(next.stream)) {\n              doReplacePublishedStream()\n            } else { // new stream is already published\n              // So we shall not replace another stream by it, but we need to unpublish the previous\n              unpublish(previous.stream)\n            }\n          }\n        }\n      } else if (previous && !next) {\n        // If position in new list is now undefined(or null) while it was in cache:\n        // unpublish if and only if stream to unpublish shall not be published (at other position)\n        if (!streamsToPublishSet.has(previous.stream)) {\n          unpublish(previous.stream)\n        }\n      } else if (!previous && next) {\n        // If position in new list is valid : publish it whatever the position in cache.\n        // Depending on the case the stream might be already published, or it might be not\n        // (can happen if the cache was set while Conversation was not joined yet).\n        // Note that we could try to publish without checking isPublishedStream, the call would\n        // reject with a console error but this would not affect the behavior.\n        if (conversation && !conversation.isPublishedStream(next.stream)) {\n          publish(next.stream, next.options).catch((error: Error) => {\n            newPublishedStreamsCache.splice(i, 1, null)\n            if (errorCallback) {\n              errorCallback(error)\n            } else if (globalThis.apirtcReactLibLogLevel.isWarnEnabled) {\n              console.warn(`${HOOK_NAME}|publish|error`, error)\n            }\n          })\n        }\n      }\n    }\n  }, [conversation,\n    streamsToPublish,\n    publishedStreamsCache,\n    publish, unpublish, replacePublishedStream]);\n\n  // --------------------------------------------------------------------------\n  // useEffect(s) - Order is important\n  //\n  useEffect(() => {\n    if (conversation) {\n      const on_streamAdded = (remoteStream: Stream) => {\n        if (globalThis.apirtcReactLibLogLevel.isInfoEnabled) {\n          console.info(HOOK_NAME + \"|on_streamAdded\", remoteStream)\n        }\n        subscribedStreams.push(remoteStream)\n        setO_SubscribedStreams(Array.from(subscribedStreams))\n      };\n      const on_streamRemoved = (remoteStream: Stream) => {\n        if (globalThis.apirtcReactLibLogLevel.isInfoEnabled) {\n          console.info(HOOK_NAME + \"|on_streamRemoved\", remoteStream)\n        }\n        const index = subscribedStreams.indexOf(remoteStream);\n        if (index >= 0) {\n          subscribedStreams.splice(index, 1)\n          setO_SubscribedStreams(Array.from(subscribedStreams))\n        }\n      };\n      const on_streamListChanged = (streamInfo: StreamInfo) => {\n        const streamId = String(streamInfo.streamId);\n        if (streamInfo.isRemote === true) {\n          if (streamInfo.listEventType === 'added') {\n            // a remote stream was published\n            conversation.subscribeToStream(streamId)\n          } else if (streamInfo.listEventType === 'removed') {\n            // a remote stream is not published anymore\n            conversation.unsubscribeToStream(streamId)\n          }\n        }\n      };\n      // Subscribe to incoming streams\n      conversation.on('streamAdded', on_streamAdded)\n      conversation.on('streamRemoved', on_streamRemoved)\n      conversation.on('streamListChanged', on_streamListChanged)\n\n      return () => {\n        // remove listeners\n        conversation.removeListener('streamListChanged', on_streamListChanged)\n        conversation.removeListener('streamRemoved', on_streamRemoved)\n        conversation.removeListener('streamAdded', on_streamAdded)\n      }\n    }\n  }, [conversation])\n\n  const unpublishAndUnsubscribeAll = (i_conversation: Conversation) => {\n    publishedStreams.forEach(stream => {\n      if (globalThis.apirtcReactLibLogLevel.isDebugEnabled) {\n        console.debug(HOOK_NAME + \"|unpublish stream\", i_conversation, stream)\n      }\n      i_conversation.unpublish(stream)\n    })\n    // Clear internal array\n    publishedStreams.length = 0;\n\n    // Clear cache\n    setPublishedStreamsCache([])\n\n    subscribedStreams.forEach(stream => {\n      if (globalThis.apirtcReactLibLogLevel.isDebugEnabled) {\n        console.debug(HOOK_NAME + \"|unsubscribeToStream stream\", i_conversation, stream)\n      }\n      i_conversation.unsubscribeToStream(stream.getId())\n    })\n    // Clear internal array\n    subscribedStreams.length = 0;\n\n    // Clear output arrays with new array so that parent gets notified of a change.\n    // Simply setting length to 0 is not detected by react.\n    setO_PublishedStreams(new Array<Stream>())\n    setO_SubscribedStreams(new Array<Stream>())\n  };\n\n  useEffect(() => {\n    if (conversation) {\n      if (globalThis.apirtcReactLibLogLevel.isDebugEnabled) {\n        console.debug(HOOK_NAME + \"|useEffect doHandlePublication\", conversation.getName())\n      }\n\n      const on_joined = () => {\n        if (globalThis.apirtcReactLibLogLevel.isInfoEnabled) {\n          console.info(HOOK_NAME + \"|on_joined\", conversation.getName(), streamsToPublish)\n        }\n        doHandlePublication()\n      };\n      const on_left = () => {\n        if (globalThis.apirtcReactLibLogLevel.isInfoEnabled) {\n          console.info(HOOK_NAME + \"|on_left\", conversation.getName())\n        }\n        // Forcing unpublish will allow to republish if joining again\n        unpublishAndUnsubscribeAll(conversation)\n      };\n\n      conversation.on('joined', on_joined)\n      conversation.on('left', on_left)\n\n      return () => {\n        conversation.removeListener('joined', on_joined)\n        conversation.removeListener('left', on_left)\n      }\n    }\n  }, [doHandlePublication]) // Don't add 'conversation' in here because\n  // doHandlePublication already changes on conversation change\n\n  // subscribeToStream(s) after having set listeners\n  //\n  useEffect(() => {\n    if (conversation) {\n      if (globalThis.apirtcReactLibLogLevel.isDebugEnabled) {\n        console.debug(`${HOOK_NAME}|conversation|${conversation.getName()}`, conversation)\n      }\n      // Subscribe to existing remote streams\n      conversation.getAvailableStreamList().forEach((streamInfo: StreamInfo) => {\n        const streamId = String(streamInfo.streamId);\n        if (streamInfo.isRemote === true) {\n          conversation.subscribeToStream(streamId)\n        }\n      })\n      return () => {\n        unpublishAndUnsubscribeAll(conversation)\n      }\n    }\n  }, [conversation])\n\n  useEffect(() => {\n    if (globalThis.apirtcReactLibLogLevel.isDebugEnabled) {\n      console.debug(`${HOOK_NAME}|streamsToPublish`,\n        JSON.stringify(streamsToPublish.map(l_s => l_s?.stream.getId() + '-' + JSON.stringify(l_s?.options))))\n    }\n    if (conversation && conversation.isJoined()) {\n      doHandlePublication()\n    }\n  }, [JSON.stringify(streamsToPublish.map(l_s => l_s?.stream.getId() + '-' + JSON.stringify(l_s?.options)))])\n\n  return {\n    publishedStreams: o_publishedStreams,\n    subscribedStreams: o_subscribedStreams,\n    publish,\n    unpublish,\n    replacePublishedStream\n  }\n}\n","import { useState, useEffect } from 'react'\nimport { Session, Contact } from '@apirtc/apirtc'\n\n/**\n * Subscribe to groups and returns contactsByGroup (of theses groups only) when updated.\n * If input groups list is updated, this hooks works diff with the previous set in order\n * to make as little as possible unsubscribe/subscribe calls.\n */\n\nconst HOOK_NAME = \"usePresence\";\nexport default function usePresence(session: Session | undefined, groups: Array<string>) {\n\n    const [groupsCache] = useState<Set<string>>(new Set());\n\n    const [m_contactsByGroup] = useState<Map<string, Set<Contact>>>(new Map());\n\n    const [contactsByGroup, setContactsByGroup] = useState<Map<string, Set<Contact>>>(new Map());\n\n    useEffect(() => {\n        if (session) {\n            return () => {\n                m_contactsByGroup.clear()\n                setContactsByGroup(new Map(m_contactsByGroup))\n                groupsCache.clear()\n            }\n        }\n    }, [session])\n\n    const getOrCreateGroupSet = (group: string) => {\n        const o_set = m_contactsByGroup.get(group) ?? new Set();\n        if (!m_contactsByGroup.has(group)) {\n            m_contactsByGroup.set(group, o_set)\n        }\n        return o_set\n    };\n\n    useEffect(() => {\n        if (globalThis.apirtcReactLibLogLevel.isDebugEnabled) {\n            console.debug(HOOK_NAME + \"|useEffect session, groups\", groups)\n        }\n        if (session) {\n            const l_session = session;\n            const l_groupsSet = new Set(groups);\n\n            // Diff update subscription to groups\n            //\n            l_groupsSet.forEach(group => {\n                if (!groupsCache.has(group)) {\n                    if (globalThis.apirtcReactLibLogLevel.isInfoEnabled) {\n                        console.info(HOOK_NAME + \"|subscribeToGroup\", group)\n                    }\n                    groupsCache.add(group)\n                    l_session.subscribeToGroup(group)\n                }\n            })\n\n            let needsRefresh = false;\n            groupsCache.forEach(group => {\n                if (!l_groupsSet.has(group)) {\n                    if (globalThis.apirtcReactLibLogLevel.isInfoEnabled) {\n                        console.info(HOOK_NAME + \"|unsubscribeToGroup\", group)\n                    }\n                    l_session.unsubscribeToGroup(group)\n                    groupsCache.delete(group)\n                    m_contactsByGroup.delete(group)\n                    needsRefresh = true;\n                }\n            })\n\n            if (needsRefresh) {\n                // contactsByGroup is exposed, so change the Map object to let client code detect a change.\n                setContactsByGroup(new Map(m_contactsByGroup))\n            }\n\n            if (groups.length > 0) {\n                const onContactListUpdate = (updatedContacts: any) => {\n\n                    if (globalThis.apirtcReactLibLogLevel.isDebugEnabled) {\n                        console.debug(HOOK_NAME + \"|contactListUpdate\", updatedContacts)\n                    }\n\n                    let needsRefresh = false;\n\n                    // Maintain Map of Contacts per Group\n                    //\n                    for (const group of Object.keys(updatedContacts.joinedGroup)) {\n                        if (l_groupsSet.has(group)) {\n                            const l_set = getOrCreateGroupSet(group);\n                            for (const contact of updatedContacts.joinedGroup[group]) {\n                                l_set.add(contact)\n                                needsRefresh = true;\n                            }\n                        }\n                    }\n                    for (const group of Object.keys(updatedContacts.leftGroup)) {\n                        if (l_groupsSet.has(group)) {\n                            const l_set = getOrCreateGroupSet(group);\n                            for (const contact of updatedContacts.leftGroup[group]) {\n                                l_set.delete(contact)\n                                needsRefresh = true;\n\n                                // if set is empty, no need to keep the group as key in the map\n                                if (l_set.size === 0) {\n                                    m_contactsByGroup.delete(group)\n                                }\n                            }\n                        }\n                    }\n\n                    // For data updates, trigger a refresh if and only if contact is part of managed groups\n                    for (const contact of updatedContacts.userDataChanged as Contact[]) {\n                        for (const l_contacts of m_contactsByGroup.values()) {\n                            if (l_contacts.has(contact)) {\n                                needsRefresh = true;\n                                break;\n                            }\n                        }\n                    }\n\n                    if (needsRefresh) {\n                        // contactsByGroup is exposed, so change the Map object to let client code detect a change.\n                        setContactsByGroup(new Map(m_contactsByGroup))\n                    }\n                };\n                l_session.on('contactListUpdate', onContactListUpdate)\n                return () => {\n                    l_session.removeListener('contactListUpdate', onContactListUpdate)\n                }\n            }\n        }\n    }, [session, JSON.stringify(groups)])\n\n    return {\n        contactsByGroup\n    }\n}","import { useEffect, useState } from 'react'\nimport { Session, UserAgent, RegisterInformation } from '@apirtc/apirtc'\n\ntype LoginPassword = {\n    username: string\n    password: string\n};\n\nfunction isInstanceOfLoginPassword(object: any): object is LoginPassword {\n    if (typeof object !== 'object') return false;\n    return 'username' in object;\n}\n\ntype ApiKey = { apiKey: string };\nfunction isInstanceOfApiKey(object: any): object is ApiKey {\n    if (typeof object !== 'object') return false;\n    return 'apiKey' in object;\n}\n\ntype Token = { token: string };\nfunction isInstanceOfToken(object: any): object is Token {\n    if (typeof object !== 'object') return false;\n    return 'token' in object;\n}\n\nexport type Credentials = LoginPassword | ApiKey | Token;\n\nconst HOOK_NAME = \"useSession\";\nexport default function useSession(credentials?: Credentials, options?: RegisterInformation) {\n\n    const [session, setSession] = useState<Session | undefined>()\n    const [connecting, setConnecting] = useState<boolean>(false)\n    const [error, setError] = useState<any>()\n\n    useEffect(() => {\n        if (globalThis.apirtcReactLibLogLevel.isDebugEnabled) {\n            console.debug(HOOK_NAME + \"|useEffect credentials, options\", credentials, options)\n        }\n        if (credentials) {\n            // To fix errors like \"Warning: Can't perform a React state update on an unmounted component\"\n            // https://stackoverflow.com/questions/53949393/cant-perform-a-react-state-update-on-an-unmounted-component\n            let isMounted = true;\n            connect(credentials, options).catch((error: any) => {\n                console.error(HOOK_NAME + \"|connection failed\", error, isMounted)\n                setSession(undefined)\n                if (isMounted) {\n                    setError(error)\n                }\n            })\n            return () => {\n                isMounted = false;\n                setSession(undefined)\n                // Even though connecting is managed in connect(),\n                // mark connecting to false when credentials are changed\n                // as this shall be way to connect elsewhere or connect to\n                // with other credentials. Note that to be perfect we should\n                // cancel the potentially running connect : Is that possible with ApiRTC ?\n                setConnecting(false)\n                setError(undefined)\n            }\n        }\n    }, [JSON.stringify(credentials), JSON.stringify(options)])\n\n    useEffect(() => {\n        if (globalThis.apirtcReactLibLogLevel.isDebugEnabled) {\n            console.debug(HOOK_NAME + \"|useEffect session\", session)\n        }\n        if (session) {\n            const l_session = session;\n            return () => {\n                l_session.disconnect().then(() => {\n                    if (globalThis.apirtcReactLibLogLevel.isInfoEnabled) {\n                        console.info(HOOK_NAME + \"|disconnected\", l_session)\n                    }\n                }).catch((error: any) => {\n                    console.error(HOOK_NAME + \"|disconnect\", error)\n                })\n            }\n        }\n    }, [session])\n\n    const connect = (credentials: Credentials | undefined, options?: RegisterInformation) => {\n        return new Promise<void>((resolve, reject) => {\n            const registerInformation: RegisterInformation = options ? options : {\n                cloudUrl: 'https://cloud.apirtc.com',\n            };\n\n            let l_userAgent;\n\n            if (isInstanceOfLoginPassword(credentials)) {\n                registerInformation.password = credentials.password;\n                l_userAgent = new UserAgent({\n                    uri: 'apirtc:' + credentials.username\n                });\n            } else if (isInstanceOfApiKey(credentials)) {\n                l_userAgent = new UserAgent({\n                    uri: `apiKey:${credentials.apiKey}`\n                });\n            } else if (isInstanceOfToken(credentials)) {\n                l_userAgent = new UserAgent({\n                    uri: `token:${credentials.token}`\n                });\n            } else {\n                reject(\"credentials not recognized\")\n                return\n            }\n\n            setConnecting(true)\n            l_userAgent.register(registerInformation).then(l_session => {\n                if (globalThis.apirtcReactLibLogLevel.isInfoEnabled) {\n                    console.info(HOOK_NAME + \"|connected\", l_session)\n                }\n                setSession(l_session)\n                resolve()\n            }).catch((error: any) => {\n                reject(error)\n            }).finally(() => {\n                setConnecting(false)\n            })\n        })\n    }\n\n    // const disconnect = useCallback(() => {\n    //     return new Promise<void>((resolve, reject) => {\n    //         if (session) {\n    //             const l_session = session;\n    //             l_session.disconnect().then(() => {\n    //                 console.log(HOOK_NAME + \"|disconnected\", l_session)\n    //                 setSession(undefined)\n    //                 resolve()\n    //             }).catch((error: any) => {\n    //                 console.error(HOOK_NAME + \"|disconnect\", error)\n    //                 reject(error)\n    //             })\n    //         } else {\n    //             resolve()\n    //         }\n    //     })\n    // }, [session])\n\n    const disconnect = () => {\n        setSession(undefined)\n    };\n\n    return {\n        //userAgent: userAgent, // can get it from session\n        session: session,\n        connecting,\n        connect,\n        disconnect,\n        error\n    }\n}\n","import { useState, useEffect, useCallback } from 'react'\nimport { Stream, VideoProcessorOptions } from '@apirtc/apirtc'\n\nconst HOOK_NAME = \"useStreamApplyVideoProcessor\";\n/**\n * This hook takes stream passed as parameter, and\n * returns either this stream or a stream with video processor applied.\n * This is controlled by the videoProcessorType input attribute.\n * By default the output stream is the input stream.\n * The hook fully manages the output stream (applies 'none' if input stream is set to undefined).\n * The hook never releases the input stream.\n * \n * @param stream \n * @returns stream blurred or not, toggle method, boolean blurred state.\n */\nexport default function useStreamApplyVideoProcessor(\n    stream: Stream | undefined,\n    videoProcessorType: 'none' | 'blur' | 'backgroundImage', options?: VideoProcessorOptions,\n    errorCallback?: (error: any) => void) {\n    //\n    const [outStream, setOutStream] = useState(stream);\n    const [applied, setApplied] = useState<'none' | 'blur' | 'backgroundImage'>('none')\n\n    useEffect(() => {\n        if (globalThis.apirtcReactLibLogLevel.isDebugEnabled) {\n            console.debug(HOOK_NAME + \"|useEffect\", stream, videoProcessorType, options)\n        }\n        if (stream && videoProcessorType !== 'none') {\n            stream.applyVideoProcessor(videoProcessorType, options).then(l_stream => {\n                setOutStream(l_stream)\n                setApplied(videoProcessorType)\n            }).catch(error => {\n                setOutStream(stream)\n                if (errorCallback) {\n                    errorCallback(error)\n                } else if (globalThis.apirtcReactLibLogLevel.isWarnEnabled) {\n                    console.warn(HOOK_NAME + \"|useEffect\", stream, videoProcessorType, options, error)\n                }\n                setApplied(previousValue => previousValue)\n            })\n        } else {\n            setOutStream(stream)\n            setApplied('none')\n        }\n    }, [stream, videoProcessorType, options])\n\n    const doCheckAndReleaseOutStream = useCallback(() => {\n        if (outStream && (outStream !== stream)) {\n            if (globalThis.apirtcReactLibLogLevel.isDebugEnabled) {\n                console.debug(HOOK_NAME + \"|releasing outStream\", outStream)\n            }\n            // stream?.applyVideoProcessor('none').catch(error => {\n            //     if (globalThis.apirtcReactLibLogLevel.isWarnEnabled) {\n            //         console.warn(HOOK_NAME + \"|doCheckAndReleaseOutStream\", stream, outStream)\n            //     }\n            // })\n            outStream.release()\n        }\n    }, [stream, outStream])\n\n    useEffect(() => {\n        return () => {\n            doCheckAndReleaseOutStream()\n        }\n    }, [outStream])\n\n    return {\n        stream: outStream,\n        applied\n    }\n}","import { useState, useEffect } from 'react'\nimport { MediaDeviceList, Session, UserAgent } from '@apirtc/apirtc'\n\nconst EMPTY_LIST: MediaDeviceList = { audioinput: {}, audiooutput: {}, videoinput: {} }\n\nconst HOOK_NAME = \"useUserMediaDevices\";\nexport default function useUserMediaDevices(\n    session: Session | undefined\n) {\n    const [userMediaDevices, setUserMediaDevices] = useState<MediaDeviceList>(EMPTY_LIST)\n\n    useEffect(() => {\n        if (session) {\n            const userAgent: UserAgent = session.getUserAgent();\n\n            const on_mediaDeviceChanged = () => {\n                const mediaDevices: MediaDeviceList = userAgent.getUserMediaDevices()\n                if (globalThis.apirtcReactLibLogLevel.isInfoEnabled) {\n                    console.info(HOOK_NAME + \"|mediaDeviceChanged\", mediaDevices)\n                }\n                setUserMediaDevices(mediaDevices)\n            };\n            userAgent.on(\"mediaDeviceChanged\", on_mediaDeviceChanged)\n\n            return () => {\n                userAgent.removeListener('mediaDeviceChanged', on_mediaDeviceChanged)\n                setUserMediaDevices(EMPTY_LIST)\n            }\n        }\n    }, [session])\n\n    return {\n        userMediaDevices\n    }\n}","export * from './components'\nexport * from './hooks'\n\ntype LogLevel = {\n    level: 'debug' | 'info' | 'warn' | 'error'\n    isDebugEnabled: boolean\n    isInfoEnabled: boolean\n    isWarnEnabled: boolean\n}\n\nconst INFO: LogLevel = { level: 'info', isDebugEnabled: false, isInfoEnabled: true, isWarnEnabled: true };\n\ndeclare global {\n    var apirtcReactLibLogLevel: LogLevel;\n    var setApirtcReactLibLogLevel: Function;\n}\n\n// a default value MUST be set in case application using the library does not override it\nglobalThis.apirtcReactLibLogLevel = INFO;\n\nexport function setLogLevel(logLevelText: 'debug' | 'info' | 'warn' | 'error' | string) {\n    switch (logLevelText) {\n        case 'debug':\n            globalThis.apirtcReactLibLogLevel = { level: 'debug', isDebugEnabled: true, isInfoEnabled: true, isWarnEnabled: true };\n            break\n        case 'info':\n            globalThis.apirtcReactLibLogLevel = INFO;\n            break\n        case 'warn':\n            globalThis.apirtcReactLibLogLevel = { level: 'warn', isDebugEnabled: false, isInfoEnabled: false, isWarnEnabled: true };\n            break\n        case 'error':\n            globalThis.apirtcReactLibLogLevel = { level: 'error', isDebugEnabled: false, isInfoEnabled: false, isWarnEnabled: false };\n            break\n        default:\n            // in case null is passed as input, default to 'info'\n            globalThis.apirtcReactLibLogLevel = INFO;\n    }\n    return globalThis.apirtcReactLibLogLevel\n}\n\nglobalThis.setApirtcReactLibLogLevel = setLogLevel;\n","import React, { useEffect, useRef } from 'react'\nimport { Stream } from '@apirtc/apirtc'\n\n// tried const Video = styled.video`\n//     max-width: 100%;\n// `\n// or\n// /* override other styles to make responsive */\n// width: 100%    !important;\n// height: auto   !important;\n// or\n// return <video width=\"100%\" ...\n//\n// but for all there is a problem then in react display...\n\nexport interface VideoStreamProps {\n    stream: Stream,\n    autoPlay?: boolean,\n    muted?: boolean\n}\nexport default function VideoStream(props: VideoStreamProps) {\n\n    // default autoPlay\n    const { autoPlay = true } = props;\n\n    const videoRef = useRef<HTMLVideoElement>(null)\n\n    useEffect(() => {\n        const ref = videoRef.current;\n        if (ref && props.stream) {\n            props.stream.attachToElement(ref)\n            return () => {\n                ref.src = \"\";\n            }\n        }\n    }, [props.stream])\n    // No need to put videoRef.current because useRef does not trigger rerender anyways\n\n    return <video id={props.stream.getId()} style={{ maxWidth: '100%' }}\n        ref={videoRef}\n        autoPlay={autoPlay}\n        muted={props.muted}></video>\n}"],"names":["HOOK_NAME","notEmpty","value","EMPTY_LIST","audioinput","audiooutput","videoinput","INFO","level","isDebugEnabled","isInfoEnabled","isWarnEnabled","setLogLevel","logLevelText","globalThis","apirtcReactLibLogLevel","setApirtcReactLibLogLevel","props","autoPlay","videoRef","useRef","useEffect","ref","current","stream","attachToElement","src","React","createElement","id","getId","style","maxWidth","muted","session","options","setStream","useState","getUserAgent","createStream","then","localStream","console","info","catch","error","undefined","JSON","stringify","release","name","join","conversation","setConversation","joined","setJoined","joining","setJoining","o_join","useCallback","debug","Promise","resolve","reject","isJoined","finally","o_leave","leave","l_conversation","getOrCreateConversation","warn","destroy","l_join","messages","Array","o_messages","setO_Messages","onMessage","message","getName","push","from","on","removeListener","length","sendMessage","msgContent","sender","uuid","content","time","Date","onEjected","onEjectedSelf","candidates","setCandidates","Set","on_contactJoinedWaitingRoom","contact","add","on_contactLeftWaitingRoom","delete","on_participantEjected","data","self","streamsToPublish","errorCallback","publishedStreamsCache","setPublishedStreamsCache","publishedStreams","o_publishedStreams","setO_PublishedStreams","subscribedStreams","o_subscribedStreams","setO_SubscribedStreams","publish","replacePublishedStream","oldStream","newStream","conversationCall","getConversationCall","index","indexOf","splice","unpublish","doHandlePublication","maxLength","Math","max","map","l_s","newPublishedStreamsCache","streamsToPublishSet","filter","item","i","previous","next","doReplacePublishedStream","has","isPublishedStream","on_streamAdded","remoteStream","on_streamRemoved","on_streamListChanged","streamInfo","streamId","String","isRemote","listEventType","subscribeToStream","unsubscribeToStream","unpublishAndUnsubscribeAll","i_conversation","forEach","on_joined","on_left","getAvailableStreamList","groups","groupsCache","m_contactsByGroup","Map","contactsByGroup","setContactsByGroup","clear","getOrCreateGroupSet","group","o_set","_a","get","set","l_session","l_groupsSet","subscribeToGroup","needsRefresh","unsubscribeToGroup","onContactListUpdate","updatedContacts","Object","keys","joinedGroup","l_set","leftGroup","size","userDataChanged","l_contacts","values","credentials","setSession","connecting","setConnecting","setError","isMounted","connect","disconnect","registerInformation","cloudUrl","l_userAgent","object","password","UserAgent","uri","username","isInstanceOfApiKey","apiKey","isInstanceOfToken","token","register","videoProcessorType","outStream","setOutStream","applied","setApplied","applyVideoProcessor","l_stream","previousValue","doCheckAndReleaseOutStream","userMediaDevices","setUserMediaDevices","userAgent","on_mediaDeviceChanged","mediaDevices","getUserMediaDevices"],"mappings":"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"}