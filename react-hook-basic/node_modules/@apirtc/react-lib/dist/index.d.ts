/// <reference types="react" />
import { Stream, Session, CreateStreamOptions, GetOrCreateConversationOptions, Conversation, ConversationMessage, Contact, PublishOptions, RegisterInformation, VideoProcessorOptions, MediaDeviceList } from '@apirtc/apirtc';

interface VideoStreamProps {
    stream: Stream;
    autoPlay?: boolean;
    muted?: boolean;
}
declare function VideoStream(props: VideoStreamProps): JSX.Element;

declare function useCameraStream(session: Session | undefined, options?: CreateStreamOptions): {
    stream: Stream | undefined;
};

/**
 * Please note that the hook won't react on autoJoin change
 */
declare function useConversation(session: Session | undefined, name: string | undefined, options?: GetOrCreateConversationOptions, join?: boolean): {
    conversation: Conversation | undefined;
    joining: boolean;
    joined: boolean;
    join: () => Promise<void>;
    leave: () => Promise<void>;
};

declare function useConversationMessages(conversation: Conversation | undefined): {
    messages: ConversationMessage[];
    sendMessage: (msgContent: string, sender: Contact) => Promise<void>;
};

declare function useConversationModeration(conversation: Conversation | undefined, onEjected?: (contact: Contact) => void, onEjectedSelf?: () => void): {
    candidates: Set<Contact>;
};

declare function useConversationStreams(conversation: Conversation | undefined, 
/** fully managed list of Stream(s) to publish, with associated publish options */
streamsToPublish?: Array<{
    stream: Stream;
    options?: PublishOptions;
} | undefined | null>, errorCallback?: (error: any) => void): {
    publishedStreams: Stream[];
    subscribedStreams: Stream[];
    publish: (localStream: Stream, options?: PublishOptions) => Promise<Stream>;
    unpublish: (localStream: Stream) => void;
    replacePublishedStream: (oldStream: Stream, newStream: Stream, options?: PublishOptions) => Promise<Stream>;
};

declare function usePresence(session: Session | undefined, groups: Array<string>): {
    contactsByGroup: Map<string, Set<Contact>>;
};

type LoginPassword = {
    username: string;
    password: string;
};
type ApiKey = {
    apiKey: string;
};
type Token = {
    token: string;
};
type Credentials = LoginPassword | ApiKey | Token;
declare function useSession(credentials?: Credentials, options?: RegisterInformation): {
    session: Session | undefined;
    connecting: boolean;
    connect: (credentials: Credentials | undefined, options?: RegisterInformation) => Promise<void>;
    disconnect: () => void;
    error: any;
};

/**
 * This hook takes stream passed as parameter, and
 * returns either this stream or a stream with video processor applied.
 * This is controlled by the videoProcessorType input attribute.
 * By default the output stream is the input stream.
 * The hook fully manages the output stream (applies 'none' if input stream is set to undefined).
 * The hook never releases the input stream.
 *
 * @param stream
 * @returns stream blurred or not, toggle method, boolean blurred state.
 */
declare function useStreamApplyVideoProcessor(stream: Stream | undefined, videoProcessorType: 'none' | 'blur' | 'backgroundImage', options?: VideoProcessorOptions, errorCallback?: (error: any) => void): {
    stream: Stream | undefined;
    applied: "none" | "blur" | "backgroundImage";
};

declare function useUserMediaDevices(session: Session | undefined): {
    userMediaDevices: MediaDeviceList;
};

type LogLevel = {
    level: 'debug' | 'info' | 'warn' | 'error';
    isDebugEnabled: boolean;
    isInfoEnabled: boolean;
    isWarnEnabled: boolean;
};
declare global {
    var apirtcReactLibLogLevel: LogLevel;
    var setApirtcReactLibLogLevel: Function;
}
declare function setLogLevel(logLevelText: 'debug' | 'info' | 'warn' | 'error' | string): LogLevel;

export { Credentials, VideoStream, setLogLevel, useCameraStream, useConversation, useConversationMessages, useConversationModeration, useConversationStreams, usePresence, useSession, useStreamApplyVideoProcessor, useUserMediaDevices };
