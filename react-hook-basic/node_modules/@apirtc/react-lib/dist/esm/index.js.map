{"version":3,"file":"index.js","sources":["../../src/components/VideoStream/VideoStream.tsx","../../src/hooks/useCameraStream.ts","../../src/hooks/useConversation.ts","../../src/hooks/useConversationMessages.ts","../../src/hooks/useConversationModeration.ts","../../src/hooks/useConversationStreams.ts","../../src/hooks/usePresence.ts","../../src/hooks/useSession.ts","../../src/hooks/useStreamApplyVideoProcessor.ts","../../src/hooks/useUserMediaDevices.ts","../../src/index.ts"],"sourcesContent":["import React, { useEffect, useRef } from 'react'\nimport { Stream } from '@apirtc/apirtc'\n\n// tried const Video = styled.video`\n//     max-width: 100%;\n// `\n// or\n// /* override other styles to make responsive */\n// width: 100%    !important;\n// height: auto   !important;\n// or\n// return <video width=\"100%\" ...\n//\n// but for all there is a problem then in react display...\n\nexport interface VideoStreamProps {\n    stream: Stream,\n    autoPlay?: boolean,\n    muted?: boolean\n}\nexport default function VideoStream(props: VideoStreamProps) {\n\n    // default autoPlay\n    const { autoPlay = true } = props;\n\n    const videoRef = useRef<HTMLVideoElement>(null)\n\n    useEffect(() => {\n        const ref = videoRef.current;\n        if (ref && props.stream) {\n            props.stream.attachToElement(ref)\n            return () => {\n                ref.src = \"\";\n            }\n        }\n    }, [props.stream])\n    // No need to put videoRef.current because useRef does not trigger rerender anyways\n\n    return <video id={props.stream.getId()} style={{ maxWidth: '100%' }}\n        ref={videoRef}\n        autoPlay={autoPlay}\n        muted={props.muted}></video>\n}","import { useState, useEffect } from 'react'\nimport { CreateStreamOptions, Session, Stream, UserAgent } from '@apirtc/apirtc'\n\nconst HOOK_NAME = \"useCameraStream\";\nexport default function useCameraStream(\n    session: Session | undefined,\n    options: CreateStreamOptions = {}\n) {\n    const [stream, setStream] = useState<Stream>();\n\n    useEffect(() => {\n        if (session) {\n            const userAgent: UserAgent = session.getUserAgent();\n            userAgent.createStream(options).then((localStream: Stream) => {\n                if (globalThis.apirtcReactLibLogLevel.isInfoEnabled) {\n                    console.info(HOOK_NAME + \"|createStream\", options, localStream)\n                }\n                setStream(localStream)\n            }).catch((error: any) => {\n                console.error(HOOK_NAME + \"|createStream\", options, error)\n                setStream(undefined)\n            })\n\n            // DO NOT set out stream to undefined in the return, to prevent unnecessary refreshes\n            // of other components with undefined stream, whereas we are expecting to change it\n            // to another instance..\n            // return () => { setStream(undefined) } // DON'T\n        } else {\n            setStream(undefined)\n        }\n\n    }, [session, JSON.stringify(options)])\n\n    useEffect(() => {\n        return () => {\n            if (stream) {\n                if (globalThis.apirtcReactLibLogLevel.isInfoEnabled) {\n                    console.info(HOOK_NAME + \"|release stream\", stream)\n                }\n                stream.release()\n            }\n        }\n    }, [stream])\n\n    return {\n        stream\n    }\n}","import { useState, useEffect, useCallback } from 'react'\nimport { Conversation, GetOrCreateConversationOptions, Session } from '@apirtc/apirtc'\n\nconst HOOK_NAME = \"useConversation\";\n/**\n * Please note that the hook won't react on autoJoin change\n */\nexport default function useConversation(\n    session: Session | undefined,\n    name: string | undefined,\n    options?: GetOrCreateConversationOptions,\n    join: boolean = false\n) {\n    const [conversation, setConversation] = useState<Conversation>();\n    const [joined, setJoined] = useState<boolean>(false);\n    const [joining, setJoining] = useState<boolean>(false);\n\n    // Callbacks\n    //\n    // Offering Promised join/leave methods allows developer to act on then/catch\n    //\n    const o_join = useCallback(() => {\n        if (globalThis.apirtcReactLibLogLevel.isDebugEnabled) {\n            console.debug(HOOK_NAME + \"|join\", conversation)\n            //JSON.stringify((apiRTC as any).session.apiCCWebRTCClient.webRTCClient.MCUClient.sessionMCUs))\n        }\n        return new Promise<void>((resolve, reject) => {\n            if (!conversation) {\n                reject(HOOK_NAME + \"|join|conversation not defined\")\n                return\n            }\n            if (!conversation.isJoined()) {\n                setJoining(true)\n                conversation.join().then(() => {\n                    // successfully joined the conversation.\n                    setJoined(true)\n                    resolve()\n                }).catch((error: any) => {\n                    // could not join the conversation.\n                    reject(error)\n                }).finally(() => {\n                    setJoining(false)\n                })\n            } else {\n                reject(HOOK_NAME + \"|join|conversation already joined\")\n            }\n        })\n    }, [conversation]);\n\n    const o_leave = useCallback(() => {\n        if (globalThis.apirtcReactLibLogLevel.isDebugEnabled) {\n            console.debug(HOOK_NAME + \"|leave\", conversation)\n        }\n        return new Promise<void>((resolve, reject) => {\n            if (!conversation) {\n                reject(HOOK_NAME + \"|leave|conversation not defined\")\n                return\n            }\n            if (conversation.isJoined()) {\n                conversation.leave().then(() => {\n                    // local user successfully left the conversation.\n                    setJoined(false)\n                    resolve()\n                }).catch((error: any) => {\n                    reject(error)\n                })\n            } else {\n                reject(HOOK_NAME + \"|leave|conversation is not joined\")\n            }\n        })\n    }, [conversation]);\n\n    // Effects\n    //\n    useEffect(() => {\n        if (session && name) {\n            if (globalThis.apirtcReactLibLogLevel.isDebugEnabled) {\n                console.debug(HOOK_NAME + \"|getOrCreateConversation\", name, options, join)\n            }\n            const l_conversation = session.getOrCreateConversation(name, options);\n            setConversation(l_conversation)\n            return () => {\n                if (globalThis.apirtcReactLibLogLevel.isDebugEnabled) {\n                    console.debug(HOOK_NAME + \"|useEffect cleanup\", name, options, join)\n                }\n                if (l_conversation.isJoined()) {\n                    l_conversation.leave()\n                        .then(() => { })\n                        .catch((error: any) => {\n                            if (globalThis.apirtcReactLibLogLevel.isWarnEnabled) {\n                                console.warn(HOOK_NAME + \"|useEffect conversation.leave()\", error)\n                            }\n                        })\n                        .finally(() => {\n                            l_conversation.destroy()\n                            setConversation(undefined)\n                            setJoined(false)\n                        })\n                } else {\n                    // It is important to destroy the conversation.\n                    // Otherwise subsequent getOrCreateConversation with same name would get\n                    // previous handle, regardless of the potentially new options.\n                    // This also allows to cleanup memory\n                    l_conversation.destroy()\n                    setConversation(undefined)\n                }\n            }\n        }\n    }, [session, name, JSON.stringify(options)])\n\n    useEffect(() => {\n        if (conversation && join) {\n            if (globalThis.apirtcReactLibLogLevel.isDebugEnabled) {\n                console.debug(HOOK_NAME + \"|useEffect\", conversation, join)\n            }\n            const l_conversation = conversation;\n            const l_join = join;\n            if (l_join) {\n                setJoining(true)\n                l_conversation.join().then(() => {\n                    if (globalThis.apirtcReactLibLogLevel.isInfoEnabled) {\n                        console.info(HOOK_NAME + \"|joined\", l_conversation)\n                    }\n                    setJoined(true)\n                }).catch((error: any) => {\n                    if (globalThis.apirtcReactLibLogLevel.isWarnEnabled) {\n                        console.warn(HOOK_NAME + \"|useEffect conversation.join()\", error)\n                    }\n                }).finally(() => {\n                    setJoining(false)\n                })\n            }\n            return () => {\n                if (globalThis.apirtcReactLibLogLevel.isDebugEnabled) {\n                    console.debug(HOOK_NAME + \"|useEffect cleanup\", l_conversation, l_join)\n                }\n                if (l_conversation.isJoined()) {\n                    l_conversation.leave().then(() => {\n                        setJoined(false)\n                    }).catch((error: any) => {\n                        if (globalThis.apirtcReactLibLogLevel.isWarnEnabled) {\n                            console.warn(HOOK_NAME + \"|useEffect conversation.leave()\", error)\n                        }\n                    })\n                }\n            }\n        }\n    }, [conversation, join])\n\n    return {\n        conversation,\n        joining,\n        joined,\n        join: o_join,\n        leave: o_leave\n    }\n}","import { useState, useEffect, useCallback } from 'react'\nimport { Contact, Conversation, ConversationMessage } from '@apirtc/apirtc'\n\n// TODO : get and handle with pagination messages history\n// TODO : ask apirtc to include the uuid in ConversationMessage so that we can store it\n// into ConversationMessage when creating the local one, and we get it from conversation on:message\n// the uuid shall be the value used as a react child key when displaying list of messages\n\nconst HOOK_NAME = \"useConversationMessages\";\nexport default function useConversationMessages(\n    conversation: Conversation | undefined,\n) {\n    // Use an internal array which will always be the same object as far as React knows\n    // This will avoid the need for adding it as a dependency for each callback\n    const [messages] = useState<Array<ConversationMessage>>(new Array<ConversationMessage>());\n    // And use a copy as output array so that client code will react upon change\n    // (only a new instance of array is detected by React)\n    const [o_messages, setO_Messages] = useState<Array<ConversationMessage>>(new Array<ConversationMessage>());\n\n    useEffect(() => {\n        if (conversation) {\n            const onMessage = (message: ConversationMessage) => {\n                if (globalThis.apirtcReactLibLogLevel.isInfoEnabled) {\n                    console.info(HOOK_NAME + \"|on:message:\", conversation.getName(), message)\n                }\n                messages.push(message)\n                setO_Messages(Array.from(messages))\n            };\n            conversation.on('message', onMessage)\n\n            return () => {\n                conversation.removeListener('message', onMessage)\n                messages.length = 0;\n                setO_Messages(new Array<any>())\n            }\n        }\n    }, [conversation])\n\n    const sendMessage = useCallback((msgContent: string, sender: Contact) => {\n        return new Promise<void>((resolve, reject) => {\n            conversation?.sendMessage(msgContent)\n                .then((uuid: number) => {\n                    if (globalThis.apirtcReactLibLogLevel.isInfoEnabled) {\n                        console.info(HOOK_NAME + \"|sentMessage\", conversation.getName(), uuid, msgContent)\n                    }\n                    messages.push({ content: msgContent, sender: sender, time: new Date() })\n                    setO_Messages(Array.from(messages))\n                    resolve()\n                })\n                .catch((error: any) => {\n                    if (globalThis.apirtcReactLibLogLevel.isWarnEnabled) {\n                        console.warn(HOOK_NAME + \"|sendMessage error\", error)\n                    }\n                    reject(error)\n                })\n        })\n    }, [conversation]);\n\n    return {\n        messages: o_messages,\n        sendMessage\n    }\n}","import { useState, useEffect } from 'react'\nimport { Contact, Conversation } from '@apirtc/apirtc'\n\nconst HOOK_NAME = \"useConversationModeration\";\nexport default function useConversationModeration(\n    conversation: Conversation | undefined,\n    onEjected?: (contact: Contact) => void,\n    onEjectedSelf?: () => void) {\n\n    const [candidates, setCandidates] = useState<Set<Contact>>(new Set<Contact>());\n\n    useEffect(() => {\n        if (globalThis.apirtcReactLibLogLevel.isDebugEnabled) {\n            console.debug(HOOK_NAME + \"|useEffect conversation\", conversation)\n        }\n\n        if (conversation) {\n            const on_contactJoinedWaitingRoom = (contact: Contact) => {\n                if (globalThis.apirtcReactLibLogLevel.isInfoEnabled) {\n                    console.info(HOOK_NAME + \"|on:contactJoinedWaitingRoom\", contact)\n                }\n                // A candidate joined the waiting room.\n                candidates.add(contact)\n                setCandidates(new Set(candidates))\n            };\n            const on_contactLeftWaitingRoom = (contact: Contact) => {\n                if (globalThis.apirtcReactLibLogLevel.isInfoEnabled) {\n                    console.info(HOOK_NAME + \"|on:contactLeftWaitingRoom\", contact)\n                }\n                // A candidate left the waiting room.\n                candidates.delete(contact)\n                setCandidates(new Set(candidates))\n            };\n            // TODO make apirtc.d.ts update to replace 'any'\n            const on_participantEjected = (data: any) => {\n                if (globalThis.apirtcReactLibLogLevel.isInfoEnabled) {\n                    console.info(HOOK_NAME + \"|on:participantEjected\", data)\n                }\n                if (data.self === true) {\n                    if (globalThis.apirtcReactLibLogLevel.isInfoEnabled) {\n                        console.info(HOOK_NAME + \"|Self participant was ejected\")\n                    }\n                    if (onEjectedSelf) {\n                        onEjectedSelf()\n                    }\n                } else {\n                    if (onEjected) {\n                        onEjected(data.contact)\n                    }\n                }\n            };\n\n            conversation\n                .on('contactJoinedWaitingRoom', on_contactJoinedWaitingRoom)\n                .on('contactLeftWaitingRoom', on_contactLeftWaitingRoom)\n                .on('participantEjected', on_participantEjected)\n\n            return () => {\n                if (globalThis.apirtcReactLibLogLevel.isDebugEnabled) {\n                    console.debug(HOOK_NAME + \"|conversation clear\", conversation)\n                }\n                // remove listeners\n                conversation\n                    .removeListener('contactJoinedWaitingRoom', on_contactJoinedWaitingRoom)\n                    .removeListener('contactLeftWaitingRoom', on_contactLeftWaitingRoom)\n                    .removeListener('participantEjected', on_participantEjected)\n                setCandidates(new Set())\n            }\n        }\n    }, [conversation])\n\n    return {\n        candidates\n    }\n}","import { useState, useEffect, useCallback } from 'react'\nimport { Conversation, PublishOptions, Stream, StreamInfo } from '@apirtc/apirtc'\n\n// TODO?: add pagination ?\n// interface Options {\n//   streamsSubscribePageSize: number\n// }\n\nfunction notEmpty<T>(value: T | null | undefined): value is T {\n  return value !== null && value !== undefined;\n}\n\nconst HOOK_NAME = \"useConversationStreams\";\nexport default function useConversationStreams(\n  conversation: Conversation | undefined,\n  /** fully managed list of Stream(s) to publish, with associated publish options */\n  streamsToPublish: Array<{ stream: Stream, options?: PublishOptions } | undefined | null> = [],\n  errorCallback?: (error: any) => void\n) {\n\n  if (globalThis.apirtcReactLibLogLevel.isDebugEnabled) {\n    console.debug(`${HOOK_NAME}|hook`)\n  }\n\n  // A cache to handle publication differences\n  const [publishedStreamsCache, setPublishedStreamsCache] =\n    useState<Array<{ stream: Stream, options?: PublishOptions } | undefined | null>>([]);\n\n  // Use an internal array which will always be the same object as far as React knows\n  // This will avoid the need for adding it as a dependency for each callback\n  const [publishedStreams] = useState<Array<Stream>>(new Array<Stream>());\n  // And use a copy as output array so that client code will react upon change\n  // (only a new instance of array is detected by React)\n  const [o_publishedStreams, setO_PublishedStreams] = useState<Array<Stream>>(new Array<Stream>());\n\n  const [subscribedStreams] = useState<Array<Stream>>(new Array<Stream>());\n  const [o_subscribedStreams, setO_SubscribedStreams] = useState<Array<Stream>>(new Array<Stream>());\n\n  const publish: (localStream: Stream, options?: PublishOptions) => Promise<Stream> =\n    useCallback((localStream: Stream, options?: PublishOptions) => {\n      return new Promise<Stream>((resolve, reject) => {\n        if (conversation) {\n          if (globalThis.apirtcReactLibLogLevel.isDebugEnabled) {\n            console.debug(`${HOOK_NAME}|publish|${conversation.getName()}`, localStream, options)\n          }\n          conversation.publish(localStream, options).then((stream: Stream) => {\n            if (globalThis.apirtcReactLibLogLevel.isInfoEnabled) {\n              console.info(`${HOOK_NAME}|published|${conversation.getName()}`, stream)\n            }\n            //console.log(`PUSHING ${stream.getId()} to publishedStreams`, JSON.stringify(publishedStreams.map(s => s.getId())))\n            publishedStreams.push(stream)\n            // Returning a new array makes lets React detect changes\n            setO_PublishedStreams(Array.from(publishedStreams))\n            resolve(stream)\n          }).catch((error: any) => {\n            reject(error)\n          })\n        }\n      })\n    }, [conversation]);\n\n  const replacePublishedStream = useCallback((oldStream: Stream, newStream: Stream, options?: PublishOptions) => {\n    return new Promise<Stream>((resolve, reject) => {\n      if (conversation) {\n        if (globalThis.apirtcReactLibLogLevel.isDebugEnabled) {\n          console.debug(`${HOOK_NAME}|replacePublishedStream|${conversation.getName()}|${oldStream.getId()} -> ${newStream.getId()}(${JSON.stringify(options)})`)\n        }\n        const conversationCall = conversation.getConversationCall(oldStream);\n        if (conversationCall) {\n          conversationCall.replacePublishedStream(newStream, undefined, options)\n            .then((stream: Stream) => {\n              if (globalThis.apirtcReactLibLogLevel.isInfoEnabled) {\n                console.info(`${HOOK_NAME}|stream replaced|${conversation.getName()}`, oldStream, stream, options)\n              }\n              const index = publishedStreams.indexOf(oldStream);\n              if (index >= 0) {\n                publishedStreams.splice(index, 1, stream)\n                setO_PublishedStreams(Array.from(publishedStreams))\n              }\n              resolve(stream)\n            }).catch((error: any) => {\n              reject(error)\n            })\n        }\n      }\n    })\n  }, [conversation]);\n\n  const unpublish: (localStream: Stream) => void = useCallback((localStream: Stream) => {\n    if (conversation) {\n      if (globalThis.apirtcReactLibLogLevel.isDebugEnabled) {\n        console.debug(`${HOOK_NAME}|unpublish|${conversation.getName()}`, localStream)\n      }\n      conversation.unpublish(localStream)\n      const index = publishedStreams.indexOf(localStream);\n      if (index >= 0) {\n        publishedStreams.splice(index, 1)\n        setO_PublishedStreams(Array.from(publishedStreams))\n      }\n    }\n  }, [conversation]);\n\n  const doHandlePublication = useCallback(() => {\n    const maxLength = Math.max(publishedStreamsCache.length, streamsToPublish.length);\n    if (globalThis.apirtcReactLibLogLevel.isDebugEnabled) {\n      console.debug(HOOK_NAME + \"|doHandlePublication\", streamsToPublish,\n        JSON.stringify(publishedStreamsCache.map(l_s => l_s?.stream.getId())), maxLength)\n    }\n\n    // Strategy for published streams cache is to initialize it as it should be\n    // and remove items if publication fails.\n    const newPublishedStreamsCache = [...streamsToPublish];\n    setPublishedStreamsCache(newPublishedStreamsCache)\n\n    // Prepare a set for Streams to publish, for further optimized check\n    const streamsToPublishSet = new Set(streamsToPublish.filter(notEmpty).map((item) => item.stream));\n\n    // Loop on arrays index to publish new streams, or replace if necessary\n    for (let i = 0; i < maxLength; i++) {\n      const previous = publishedStreamsCache[i];\n      const next = streamsToPublish[i];\n\n      if (previous && next) {\n        const doReplacePublishedStream = () => {\n          replacePublishedStream(previous.stream, next.stream, next.options)\n            .catch((error: Error) => {\n              newPublishedStreamsCache.splice(i, 1, null)\n              if (errorCallback) {\n                errorCallback(error)\n              } else if (globalThis.apirtcReactLibLogLevel.isWarnEnabled) {\n                console.warn(`${HOOK_NAME}|replacePublishedStream|error`, error)\n              }\n            })\n        }\n        if (previous.stream === next.stream) {\n          // Streams are the same, only replace if options are different\n          if (JSON.stringify(previous.options) !== JSON.stringify(next.options)) {\n            doReplacePublishedStream()\n          }\n        } else {\n          // If position in both new and cached list are defined but are different:\n          // replace if and only if stream to unpublish shall not be published (at other position)\n          if (streamsToPublishSet.has(previous.stream)) { // previous shall be published\n            // Previous shall actually be published (at another position), so don't do anything about it\n            // But then we still have to publish new stream (if not already published)\n            if (conversation && !conversation.isPublishedStream(next.stream)) {\n              publish(next.stream, next.options).catch((error: Error) => {\n                newPublishedStreamsCache.splice(i, 1, null)\n                if (errorCallback) {\n                  errorCallback(error)\n                } else if (globalThis.apirtcReactLibLogLevel.isWarnEnabled) {\n                  console.warn(`${HOOK_NAME}|publish|error`, error)\n                }\n              })\n            }\n          } else {\n            if (conversation && !conversation.isPublishedStream(next.stream)) {\n              doReplacePublishedStream()\n            } else { // new stream is already published\n              // So we shall not replace another stream by it, but we need to unpublish the previous\n              unpublish(previous.stream)\n            }\n          }\n        }\n      } else if (previous && !next) {\n        // If position in new list is now undefined(or null) while it was in cache:\n        // unpublish if and only if stream to unpublish shall not be published (at other position)\n        if (!streamsToPublishSet.has(previous.stream)) {\n          unpublish(previous.stream)\n        }\n      } else if (!previous && next) {\n        // If position in new list is valid : publish it whatever the position in cache.\n        // Depending on the case the stream might be already published, or it might be not\n        // (can happen if the cache was set while Conversation was not joined yet).\n        // Note that we could try to publish without checking isPublishedStream, the call would\n        // reject with a console error but this would not affect the behavior.\n        if (conversation && !conversation.isPublishedStream(next.stream)) {\n          publish(next.stream, next.options).catch((error: Error) => {\n            newPublishedStreamsCache.splice(i, 1, null)\n            if (errorCallback) {\n              errorCallback(error)\n            } else if (globalThis.apirtcReactLibLogLevel.isWarnEnabled) {\n              console.warn(`${HOOK_NAME}|publish|error`, error)\n            }\n          })\n        }\n      }\n    }\n  }, [conversation,\n    streamsToPublish,\n    publishedStreamsCache,\n    publish, unpublish, replacePublishedStream]);\n\n  // --------------------------------------------------------------------------\n  // useEffect(s) - Order is important\n  //\n  useEffect(() => {\n    if (conversation) {\n      const on_streamAdded = (remoteStream: Stream) => {\n        if (globalThis.apirtcReactLibLogLevel.isInfoEnabled) {\n          console.info(HOOK_NAME + \"|on_streamAdded\", remoteStream)\n        }\n        subscribedStreams.push(remoteStream)\n        setO_SubscribedStreams(Array.from(subscribedStreams))\n      };\n      const on_streamRemoved = (remoteStream: Stream) => {\n        if (globalThis.apirtcReactLibLogLevel.isInfoEnabled) {\n          console.info(HOOK_NAME + \"|on_streamRemoved\", remoteStream)\n        }\n        const index = subscribedStreams.indexOf(remoteStream);\n        if (index >= 0) {\n          subscribedStreams.splice(index, 1)\n          setO_SubscribedStreams(Array.from(subscribedStreams))\n        }\n      };\n      const on_streamListChanged = (streamInfo: StreamInfo) => {\n        const streamId = String(streamInfo.streamId);\n        if (streamInfo.isRemote === true) {\n          if (streamInfo.listEventType === 'added') {\n            // a remote stream was published\n            conversation.subscribeToStream(streamId)\n          } else if (streamInfo.listEventType === 'removed') {\n            // a remote stream is not published anymore\n            conversation.unsubscribeToStream(streamId)\n          }\n        }\n      };\n      // Subscribe to incoming streams\n      conversation.on('streamAdded', on_streamAdded)\n      conversation.on('streamRemoved', on_streamRemoved)\n      conversation.on('streamListChanged', on_streamListChanged)\n\n      return () => {\n        // remove listeners\n        conversation.removeListener('streamListChanged', on_streamListChanged)\n        conversation.removeListener('streamRemoved', on_streamRemoved)\n        conversation.removeListener('streamAdded', on_streamAdded)\n      }\n    }\n  }, [conversation])\n\n  const unpublishAndUnsubscribeAll = (i_conversation: Conversation) => {\n    publishedStreams.forEach(stream => {\n      if (globalThis.apirtcReactLibLogLevel.isDebugEnabled) {\n        console.debug(HOOK_NAME + \"|unpublish stream\", i_conversation, stream)\n      }\n      i_conversation.unpublish(stream)\n    })\n    // Clear internal array\n    publishedStreams.length = 0;\n\n    // Clear cache\n    setPublishedStreamsCache([])\n\n    subscribedStreams.forEach(stream => {\n      if (globalThis.apirtcReactLibLogLevel.isDebugEnabled) {\n        console.debug(HOOK_NAME + \"|unsubscribeToStream stream\", i_conversation, stream)\n      }\n      i_conversation.unsubscribeToStream(stream.getId())\n    })\n    // Clear internal array\n    subscribedStreams.length = 0;\n\n    // Clear output arrays with new array so that parent gets notified of a change.\n    // Simply setting length to 0 is not detected by react.\n    setO_PublishedStreams(new Array<Stream>())\n    setO_SubscribedStreams(new Array<Stream>())\n  };\n\n  useEffect(() => {\n    if (conversation) {\n      if (globalThis.apirtcReactLibLogLevel.isDebugEnabled) {\n        console.debug(HOOK_NAME + \"|useEffect doHandlePublication\", conversation.getName())\n      }\n\n      const on_joined = () => {\n        if (globalThis.apirtcReactLibLogLevel.isInfoEnabled) {\n          console.info(HOOK_NAME + \"|on_joined\", conversation.getName(), streamsToPublish)\n        }\n        doHandlePublication()\n      };\n      const on_left = () => {\n        if (globalThis.apirtcReactLibLogLevel.isInfoEnabled) {\n          console.info(HOOK_NAME + \"|on_left\", conversation.getName())\n        }\n        // Forcing unpublish will allow to republish if joining again\n        unpublishAndUnsubscribeAll(conversation)\n      };\n\n      conversation.on('joined', on_joined)\n      conversation.on('left', on_left)\n\n      return () => {\n        conversation.removeListener('joined', on_joined)\n        conversation.removeListener('left', on_left)\n      }\n    }\n  }, [doHandlePublication]) // Don't add 'conversation' in here because\n  // doHandlePublication already changes on conversation change\n\n  // subscribeToStream(s) after having set listeners\n  //\n  useEffect(() => {\n    if (conversation) {\n      if (globalThis.apirtcReactLibLogLevel.isDebugEnabled) {\n        console.debug(`${HOOK_NAME}|conversation|${conversation.getName()}`, conversation)\n      }\n      // Subscribe to existing remote streams\n      conversation.getAvailableStreamList().forEach((streamInfo: StreamInfo) => {\n        const streamId = String(streamInfo.streamId);\n        if (streamInfo.isRemote === true) {\n          conversation.subscribeToStream(streamId)\n        }\n      })\n      return () => {\n        unpublishAndUnsubscribeAll(conversation)\n      }\n    }\n  }, [conversation])\n\n  useEffect(() => {\n    if (globalThis.apirtcReactLibLogLevel.isDebugEnabled) {\n      console.debug(`${HOOK_NAME}|streamsToPublish`,\n        JSON.stringify(streamsToPublish.map(l_s => l_s?.stream.getId() + '-' + JSON.stringify(l_s?.options))))\n    }\n    if (conversation && conversation.isJoined()) {\n      doHandlePublication()\n    }\n  }, [JSON.stringify(streamsToPublish.map(l_s => l_s?.stream.getId() + '-' + JSON.stringify(l_s?.options)))])\n\n  return {\n    publishedStreams: o_publishedStreams,\n    subscribedStreams: o_subscribedStreams,\n    publish,\n    unpublish,\n    replacePublishedStream\n  }\n}\n","import { useState, useEffect } from 'react'\nimport { Session, Contact } from '@apirtc/apirtc'\n\n/**\n * Subscribe to groups and returns contactsByGroup (of theses groups only) when updated.\n * If input groups list is updated, this hooks works diff with the previous set in order\n * to make as little as possible unsubscribe/subscribe calls.\n */\n\nconst HOOK_NAME = \"usePresence\";\nexport default function usePresence(session: Session | undefined, groups: Array<string>) {\n\n    const [groupsCache] = useState<Set<string>>(new Set());\n\n    const [m_contactsByGroup] = useState<Map<string, Set<Contact>>>(new Map());\n\n    const [contactsByGroup, setContactsByGroup] = useState<Map<string, Set<Contact>>>(new Map());\n\n    useEffect(() => {\n        if (session) {\n            return () => {\n                m_contactsByGroup.clear()\n                setContactsByGroup(new Map(m_contactsByGroup))\n                groupsCache.clear()\n            }\n        }\n    }, [session])\n\n    const getOrCreateGroupSet = (group: string) => {\n        const o_set = m_contactsByGroup.get(group) ?? new Set();\n        if (!m_contactsByGroup.has(group)) {\n            m_contactsByGroup.set(group, o_set)\n        }\n        return o_set\n    };\n\n    useEffect(() => {\n        if (globalThis.apirtcReactLibLogLevel.isDebugEnabled) {\n            console.debug(HOOK_NAME + \"|useEffect session, groups\", groups)\n        }\n        if (session) {\n            const l_session = session;\n            const l_groupsSet = new Set(groups);\n\n            // Diff update subscription to groups\n            //\n            l_groupsSet.forEach(group => {\n                if (!groupsCache.has(group)) {\n                    if (globalThis.apirtcReactLibLogLevel.isInfoEnabled) {\n                        console.info(HOOK_NAME + \"|subscribeToGroup\", group)\n                    }\n                    groupsCache.add(group)\n                    l_session.subscribeToGroup(group)\n                }\n            })\n\n            let needsRefresh = false;\n            groupsCache.forEach(group => {\n                if (!l_groupsSet.has(group)) {\n                    if (globalThis.apirtcReactLibLogLevel.isInfoEnabled) {\n                        console.info(HOOK_NAME + \"|unsubscribeToGroup\", group)\n                    }\n                    l_session.unsubscribeToGroup(group)\n                    groupsCache.delete(group)\n                    m_contactsByGroup.delete(group)\n                    needsRefresh = true;\n                }\n            })\n\n            if (needsRefresh) {\n                // contactsByGroup is exposed, so change the Map object to let client code detect a change.\n                setContactsByGroup(new Map(m_contactsByGroup))\n            }\n\n            if (groups.length > 0) {\n                const onContactListUpdate = (updatedContacts: any) => {\n\n                    if (globalThis.apirtcReactLibLogLevel.isDebugEnabled) {\n                        console.debug(HOOK_NAME + \"|contactListUpdate\", updatedContacts)\n                    }\n\n                    let needsRefresh = false;\n\n                    // Maintain Map of Contacts per Group\n                    //\n                    for (const group of Object.keys(updatedContacts.joinedGroup)) {\n                        if (l_groupsSet.has(group)) {\n                            const l_set = getOrCreateGroupSet(group);\n                            for (const contact of updatedContacts.joinedGroup[group]) {\n                                l_set.add(contact)\n                                needsRefresh = true;\n                            }\n                        }\n                    }\n                    for (const group of Object.keys(updatedContacts.leftGroup)) {\n                        if (l_groupsSet.has(group)) {\n                            const l_set = getOrCreateGroupSet(group);\n                            for (const contact of updatedContacts.leftGroup[group]) {\n                                l_set.delete(contact)\n                                needsRefresh = true;\n\n                                // if set is empty, no need to keep the group as key in the map\n                                if (l_set.size === 0) {\n                                    m_contactsByGroup.delete(group)\n                                }\n                            }\n                        }\n                    }\n\n                    // For data updates, trigger a refresh if and only if contact is part of managed groups\n                    for (const contact of updatedContacts.userDataChanged as Contact[]) {\n                        for (const l_contacts of m_contactsByGroup.values()) {\n                            if (l_contacts.has(contact)) {\n                                needsRefresh = true;\n                                break;\n                            }\n                        }\n                    }\n\n                    if (needsRefresh) {\n                        // contactsByGroup is exposed, so change the Map object to let client code detect a change.\n                        setContactsByGroup(new Map(m_contactsByGroup))\n                    }\n                };\n                l_session.on('contactListUpdate', onContactListUpdate)\n                return () => {\n                    l_session.removeListener('contactListUpdate', onContactListUpdate)\n                }\n            }\n        }\n    }, [session, JSON.stringify(groups)])\n\n    return {\n        contactsByGroup\n    }\n}","import { useEffect, useState } from 'react'\nimport { Session, UserAgent, RegisterInformation } from '@apirtc/apirtc'\n\ntype LoginPassword = {\n    username: string\n    password: string\n};\n\nfunction isInstanceOfLoginPassword(object: any): object is LoginPassword {\n    if (typeof object !== 'object') return false;\n    return 'username' in object;\n}\n\ntype ApiKey = { apiKey: string };\nfunction isInstanceOfApiKey(object: any): object is ApiKey {\n    if (typeof object !== 'object') return false;\n    return 'apiKey' in object;\n}\n\ntype Token = { token: string };\nfunction isInstanceOfToken(object: any): object is Token {\n    if (typeof object !== 'object') return false;\n    return 'token' in object;\n}\n\nexport type Credentials = LoginPassword | ApiKey | Token;\n\nconst HOOK_NAME = \"useSession\";\nexport default function useSession(credentials?: Credentials, options?: RegisterInformation) {\n\n    const [session, setSession] = useState<Session | undefined>()\n    const [connecting, setConnecting] = useState<boolean>(false)\n    const [error, setError] = useState<any>()\n\n    useEffect(() => {\n        if (globalThis.apirtcReactLibLogLevel.isDebugEnabled) {\n            console.debug(HOOK_NAME + \"|useEffect credentials, options\", credentials, options)\n        }\n        if (credentials) {\n            // To fix errors like \"Warning: Can't perform a React state update on an unmounted component\"\n            // https://stackoverflow.com/questions/53949393/cant-perform-a-react-state-update-on-an-unmounted-component\n            let isMounted = true;\n            connect(credentials, options).catch((error: any) => {\n                console.error(HOOK_NAME + \"|connection failed\", error, isMounted)\n                setSession(undefined)\n                if (isMounted) {\n                    setError(error)\n                }\n            })\n            return () => {\n                isMounted = false;\n                setSession(undefined)\n                // Even though connecting is managed in connect(),\n                // mark connecting to false when credentials are changed\n                // as this shall be way to connect elsewhere or connect to\n                // with other credentials. Note that to be perfect we should\n                // cancel the potentially running connect : Is that possible with ApiRTC ?\n                setConnecting(false)\n                setError(undefined)\n            }\n        }\n    }, [JSON.stringify(credentials), JSON.stringify(options)])\n\n    useEffect(() => {\n        if (globalThis.apirtcReactLibLogLevel.isDebugEnabled) {\n            console.debug(HOOK_NAME + \"|useEffect session\", session)\n        }\n        if (session) {\n            const l_session = session;\n            return () => {\n                l_session.disconnect().then(() => {\n                    if (globalThis.apirtcReactLibLogLevel.isInfoEnabled) {\n                        console.info(HOOK_NAME + \"|disconnected\", l_session)\n                    }\n                }).catch((error: any) => {\n                    console.error(HOOK_NAME + \"|disconnect\", error)\n                })\n            }\n        }\n    }, [session])\n\n    const connect = (credentials: Credentials | undefined, options?: RegisterInformation) => {\n        return new Promise<void>((resolve, reject) => {\n            const registerInformation: RegisterInformation = options ? options : {\n                cloudUrl: 'https://cloud.apirtc.com',\n            };\n\n            let l_userAgent;\n\n            if (isInstanceOfLoginPassword(credentials)) {\n                registerInformation.password = credentials.password;\n                l_userAgent = new UserAgent({\n                    uri: 'apirtc:' + credentials.username\n                });\n            } else if (isInstanceOfApiKey(credentials)) {\n                l_userAgent = new UserAgent({\n                    uri: `apiKey:${credentials.apiKey}`\n                });\n            } else if (isInstanceOfToken(credentials)) {\n                l_userAgent = new UserAgent({\n                    uri: `token:${credentials.token}`\n                });\n            } else {\n                reject(\"credentials not recognized\")\n                return\n            }\n\n            setConnecting(true)\n            l_userAgent.register(registerInformation).then(l_session => {\n                if (globalThis.apirtcReactLibLogLevel.isInfoEnabled) {\n                    console.info(HOOK_NAME + \"|connected\", l_session)\n                }\n                setSession(l_session)\n                resolve()\n            }).catch((error: any) => {\n                reject(error)\n            }).finally(() => {\n                setConnecting(false)\n            })\n        })\n    }\n\n    // const disconnect = useCallback(() => {\n    //     return new Promise<void>((resolve, reject) => {\n    //         if (session) {\n    //             const l_session = session;\n    //             l_session.disconnect().then(() => {\n    //                 console.log(HOOK_NAME + \"|disconnected\", l_session)\n    //                 setSession(undefined)\n    //                 resolve()\n    //             }).catch((error: any) => {\n    //                 console.error(HOOK_NAME + \"|disconnect\", error)\n    //                 reject(error)\n    //             })\n    //         } else {\n    //             resolve()\n    //         }\n    //     })\n    // }, [session])\n\n    const disconnect = () => {\n        setSession(undefined)\n    };\n\n    return {\n        //userAgent: userAgent, // can get it from session\n        session: session,\n        connecting,\n        connect,\n        disconnect,\n        error\n    }\n}\n","import { useState, useEffect, useCallback } from 'react'\nimport { Stream, VideoProcessorOptions } from '@apirtc/apirtc'\n\nconst HOOK_NAME = \"useStreamApplyVideoProcessor\";\n/**\n * This hook takes stream passed as parameter, and\n * returns either this stream or a stream with video processor applied.\n * This is controlled by the videoProcessorType input attribute.\n * By default the output stream is the input stream.\n * The hook fully manages the output stream (applies 'none' if input stream is set to undefined).\n * The hook never releases the input stream.\n * \n * @param stream \n * @returns stream blurred or not, toggle method, boolean blurred state.\n */\nexport default function useStreamApplyVideoProcessor(\n    stream: Stream | undefined,\n    videoProcessorType: 'none' | 'blur' | 'backgroundImage', options?: VideoProcessorOptions,\n    errorCallback?: (error: any) => void) {\n    //\n    const [outStream, setOutStream] = useState(stream);\n    const [applied, setApplied] = useState<'none' | 'blur' | 'backgroundImage'>('none')\n\n    useEffect(() => {\n        if (globalThis.apirtcReactLibLogLevel.isDebugEnabled) {\n            console.debug(HOOK_NAME + \"|useEffect\", stream, videoProcessorType, options)\n        }\n        if (stream && videoProcessorType !== 'none') {\n            stream.applyVideoProcessor(videoProcessorType, options).then(l_stream => {\n                setOutStream(l_stream)\n                setApplied(videoProcessorType)\n            }).catch(error => {\n                setOutStream(stream)\n                if (errorCallback) {\n                    errorCallback(error)\n                } else if (globalThis.apirtcReactLibLogLevel.isWarnEnabled) {\n                    console.warn(HOOK_NAME + \"|useEffect\", stream, videoProcessorType, options, error)\n                }\n                setApplied(previousValue => previousValue)\n            })\n        } else {\n            setOutStream(stream)\n            setApplied('none')\n        }\n    }, [stream, videoProcessorType, options])\n\n    const doCheckAndReleaseOutStream = useCallback(() => {\n        if (outStream && (outStream !== stream)) {\n            if (globalThis.apirtcReactLibLogLevel.isDebugEnabled) {\n                console.debug(HOOK_NAME + \"|releasing outStream\", outStream)\n            }\n            // stream?.applyVideoProcessor('none').catch(error => {\n            //     if (globalThis.apirtcReactLibLogLevel.isWarnEnabled) {\n            //         console.warn(HOOK_NAME + \"|doCheckAndReleaseOutStream\", stream, outStream)\n            //     }\n            // })\n            outStream.release()\n        }\n    }, [stream, outStream])\n\n    useEffect(() => {\n        return () => {\n            doCheckAndReleaseOutStream()\n        }\n    }, [outStream])\n\n    return {\n        stream: outStream,\n        applied\n    }\n}","import { useState, useEffect } from 'react'\nimport { MediaDeviceList, Session, UserAgent } from '@apirtc/apirtc'\n\nconst EMPTY_LIST: MediaDeviceList = { audioinput: {}, audiooutput: {}, videoinput: {} }\n\nconst HOOK_NAME = \"useUserMediaDevices\";\nexport default function useUserMediaDevices(\n    session: Session | undefined\n) {\n    const [userMediaDevices, setUserMediaDevices] = useState<MediaDeviceList>(EMPTY_LIST)\n\n    useEffect(() => {\n        if (session) {\n            const userAgent: UserAgent = session.getUserAgent();\n\n            const on_mediaDeviceChanged = () => {\n                const mediaDevices: MediaDeviceList = userAgent.getUserMediaDevices()\n                if (globalThis.apirtcReactLibLogLevel.isInfoEnabled) {\n                    console.info(HOOK_NAME + \"|mediaDeviceChanged\", mediaDevices)\n                }\n                setUserMediaDevices(mediaDevices)\n            };\n            userAgent.on(\"mediaDeviceChanged\", on_mediaDeviceChanged)\n\n            return () => {\n                userAgent.removeListener('mediaDeviceChanged', on_mediaDeviceChanged)\n                setUserMediaDevices(EMPTY_LIST)\n            }\n        }\n    }, [session])\n\n    return {\n        userMediaDevices\n    }\n}","export * from './components'\nexport * from './hooks'\n\ntype LogLevel = {\n    level: 'debug' | 'info' | 'warn' | 'error'\n    isDebugEnabled: boolean\n    isInfoEnabled: boolean\n    isWarnEnabled: boolean\n}\n\nconst INFO: LogLevel = { level: 'info', isDebugEnabled: false, isInfoEnabled: true, isWarnEnabled: true };\n\ndeclare global {\n    var apirtcReactLibLogLevel: LogLevel;\n    var setApirtcReactLibLogLevel: Function;\n}\n\n// a default value MUST be set in case application using the library does not override it\nglobalThis.apirtcReactLibLogLevel = INFO;\n\nexport function setLogLevel(logLevelText: 'debug' | 'info' | 'warn' | 'error' | string) {\n    switch (logLevelText) {\n        case 'debug':\n            globalThis.apirtcReactLibLogLevel = { level: 'debug', isDebugEnabled: true, isInfoEnabled: true, isWarnEnabled: true };\n            break\n        case 'info':\n            globalThis.apirtcReactLibLogLevel = INFO;\n            break\n        case 'warn':\n            globalThis.apirtcReactLibLogLevel = { level: 'warn', isDebugEnabled: false, isInfoEnabled: false, isWarnEnabled: true };\n            break\n        case 'error':\n            globalThis.apirtcReactLibLogLevel = { level: 'error', isDebugEnabled: false, isInfoEnabled: false, isWarnEnabled: false };\n            break\n        default:\n            // in case null is passed as input, default to 'info'\n            globalThis.apirtcReactLibLogLevel = INFO;\n    }\n    return globalThis.apirtcReactLibLogLevel\n}\n\nglobalThis.setApirtcReactLibLogLevel = setLogLevel;\n"],"names":["VideoStream","props","autoPlay","videoRef","useRef","useEffect","ref","current","stream","attachToElement","src","React","createElement","id","getId","style","maxWidth","muted","HOOK_NAME","useCameraStream","session","options","setStream","useState","getUserAgent","createStream","then","localStream","globalThis","apirtcReactLibLogLevel","isInfoEnabled","console","info","catch","error","undefined","JSON","stringify","release","useConversation","name","join","conversation","setConversation","joined","setJoined","joining","setJoining","o_join","useCallback","isDebugEnabled","debug","Promise","resolve","reject","isJoined","finally","o_leave","leave","l_conversation","getOrCreateConversation","isWarnEnabled","warn","destroy","l_join","useConversationMessages","messages","Array","o_messages","setO_Messages","onMessage","message","getName","push","from","on","removeListener","length","sendMessage","msgContent","sender","uuid","content","time","Date","useConversationModeration","onEjected","onEjectedSelf","candidates","setCandidates","Set","on_contactJoinedWaitingRoom","contact","add","on_contactLeftWaitingRoom","delete","on_participantEjected","data","self","notEmpty","value","useConversationStreams","streamsToPublish","errorCallback","publishedStreamsCache","setPublishedStreamsCache","publishedStreams","o_publishedStreams","setO_PublishedStreams","subscribedStreams","o_subscribedStreams","setO_SubscribedStreams","publish","replacePublishedStream","oldStream","newStream","conversationCall","getConversationCall","index","indexOf","splice","unpublish","doHandlePublication","maxLength","Math","max","map","l_s","newPublishedStreamsCache","streamsToPublishSet","filter","item","i","previous","next","doReplacePublishedStream","has","isPublishedStream","on_streamAdded","remoteStream","on_streamRemoved","on_streamListChanged","streamInfo","streamId","String","isRemote","listEventType","subscribeToStream","unsubscribeToStream","unpublishAndUnsubscribeAll","i_conversation","forEach","on_joined","on_left","getAvailableStreamList","usePresence","groups","groupsCache","m_contactsByGroup","Map","contactsByGroup","setContactsByGroup","clear","getOrCreateGroupSet","group","o_set","_a","get","set","l_session","l_groupsSet","subscribeToGroup","needsRefresh","unsubscribeToGroup","onContactListUpdate","updatedContacts","Object","keys","joinedGroup","l_set","leftGroup","size","userDataChanged","l_contacts","values","useSession","credentials","setSession","connecting","setConnecting","setError","isMounted","connect","disconnect","registerInformation","cloudUrl","l_userAgent","object","password","UserAgent","uri","username","isInstanceOfApiKey","apiKey","isInstanceOfToken","token","register","useStreamApplyVideoProcessor","videoProcessorType","outStream","setOutStream","applied","setApplied","applyVideoProcessor","l_stream","previousValue","doCheckAndReleaseOutStream","EMPTY_LIST","audioinput","audiooutput","videoinput","useUserMediaDevices","userMediaDevices","setUserMediaDevices","userAgent","on_mediaDeviceChanged","mediaDevices","getUserMediaDevices","INFO","level","setLogLevel","logLevelText","setApirtcReactLibLogLevel"],"mappings":"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"}